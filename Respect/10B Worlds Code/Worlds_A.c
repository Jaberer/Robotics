#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    PotentL,        sensorPotentiometer)
#pragma config(Sensor, in4,    PotentR,        sensorPotentiometer)
#pragma config(Sensor, dgtl3,  Switch0,        sensorTouch)
#pragma config(Sensor, dgtl4,  Switch1,        sensorTouch)
#pragma config(Sensor, dgtl5,  Switch2,        sensorTouch)
#pragma config(Sensor, dgtl6,  TowerLimitL,    sensorTouch)
#pragma config(Sensor, dgtl7,  TowerLimitR,    sensorTouch)
#pragma config(Sensor, dgtl8,  ButtonBlockR,   sensorTouch)
#pragma config(Sensor, dgtl9,  ButtonWait,     sensorTouch)
#pragma config(Sensor, dgtl10, ButtonBlockL,   sensorTouch)
#pragma config(Sensor, dgtl11, TrayPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl12, PlatformPiston, sensorDigitalOut)
#pragma config(Sensor, I2C_1,  EncoderR,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           DriveRB,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port2,           ArmRT,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           RollerR,       tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           ArmRB,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           DriveRF,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port6,           DriveLF,       tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           ArmLB,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,           RollerL,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port9,           ArmLT,         tmotorVex393, openLoop)
#pragma config(Motor,  port10,          DriveLB,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Worlds_U.c"





void theSohum() // 5-1-5, score
{
	resetEncoders();
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );

	setRobot( 1545, 'S', 0, 127, 0, 1, 1700 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1200 );
	setRobot( -337, 'T', 0, 127, 0, 0, 1000 );
	setRobot( 2800, 'S', 0, 127, 0, 0, 1750 );
	setRobot( 0, 'S', 0, 127, 0, 0, 500 );
	setRobot( -1650, 'S', 1700, 40, 0, 0, 2500 );
	setRobot( 315, 'T', 1700, 0, 0, 0, 1500 );
	setRobotPhysLimit( 1275, 'S', 1700, 40, 0, 0, 1500 );

	/*setRobot( -350, 'S', 1700, 0, 0, 0, 1200);
	setRobot( 0, 'S', 1700, -127, 1, 0, 1200 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 ); */
	moveDrive(-80, -80);
	wait1Msec(420);
	moveDrive(0, 0);
	setRobot( 0, 'S', 1700, -127, 1, 0, 1400 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
}

void theSohumLeft() // 5-1-5, score
{
	resetEncoders();
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );

	setRobot( 1545, 'S', 0, 127, 0, 1, 1700 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1200 );
	setRobot( 337, 'T', 0, 127, 0, 0, 1000 );
	setRobot( 2800, 'S', 0, 127, 0, 0, 1750 );
	setRobot( 0, 'S', 0, 127, 0, 0, 500 );
	setRobot( -1650, 'S', 1700, 40, 0, 0, 2500 );
	setRobot( -345, 'T', 1700, 0, 0, 0, 1500 );
	setRobotPhysLimit( 1275, 'S', 1700, 40, 0, 0, 1500 );
	moveDrive(-80, -80);
	wait1Msec(420);
	moveDrive(0, 0);
	setRobot( 0, 'S', 1700, -127, 1, 0, 1400 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
}

void theSamvit()
{
	resetEncoders();
	//Daniel please uncomment the following when ready
	setRobot( 0, 'S', 0, 0, 0, 0, 500 );
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );

	setRobot( 1545, 'S', 0, 127, 0, 1, 1700 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1200 );
	setRobot( -323, 'T', 0, 127, 0, 0, 1000 );
	setRobot( 982, 'S', 0, 127, 0, 0, 1250 );
	setRobot( 0, 'S', 0, 127, 0, 0, 500 );
	setRobot( -715, 'S', 1700, 80, 0, 0, 1250 );
	setRobot( 315, 'T', 1700, 80, 0, 0, 1500 );
	setRobotPhysLimit( 1275, 'S', 1700, 40, 0, 0, 1500 );
	// Daniel i have taken this out because it knocked over the ROBOT
	//adjust the power and figure out what is neccessary time wise --Chinmay
	int sum = SensorValue[TowerLimitL] * 2 + SensorValue[TowerLimitR];
	bool touching = SensorValue[TowerLimitL] || SensorValue[TowerLimitR];
	moveArm(35, 35);
	if(sum == 3)
	{
		moveDrive(40, 40);
	}
	else if(sum == 2)
	{
		moveDrive(40, 70);
	}
	else if(sum == 1)
	{
		moveDrive(70, 40);
	}
	else if(sum == 0)
	{
		moveDrive(70, 70);
	}
	ClearTimer(T2);
	while(time1[T2] < 200 && (!SensorValue[TowerLimitL] || !SensorValue[TowerLimitR])) {}
	moveDrive(0, 0);
	wait1Msec(200);
	moveDrive(-80, -80);
	wait1Msec(420);
	moveDrive(0, 0);
	if(touching)
	{
	setRobot( 0, 'S', 1700, -127, 1, 0, 1400 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );
	}
	setRobot( 0, 'S', 0, 0, 0, 0, 15000 );
}

void theSamvitLeft()
{
	resetEncoders();
	//Daniel please uncomment the following when ready
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );

	setRobot( 1545, 'S', 0, 127, 0, 1, 1700 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1000 );
	setRobot( 312, 'T', 0, 127, 0, 0, 1200 );
	setRobot( 982, 'S', 0, 127, 0, 0, 1250 );
	setRobot( 0, 'S', 0, 127, 0, 0, 500 );
	setRobot( -1665, 'S', 1700, 80, 0, 0, 2550 );
	setRobot( -375, 'T', 1700, 80, 0, 0, 1500 );
	setRobotPhysLimit( 1275, 'S', 1700, 40, 0, 0, 1500 );
	bool touching = SensorValue[TowerLimitL] || SensorValue[TowerLimitR];
	//Daniel i have taken this out because it knocked over the ROBOT
	//adjust the power and figure out what is neccessary time wise --Chinmay
	int sum = SensorValue[TowerLimitL] * 2 + SensorValue[TowerLimitR];
	moveArm(35, 35);
	if(sum == 3)
	{
		moveDrive(40, 40);
	}
	else if(sum == 2)
	{
		moveDrive(40, 70);
	}
	else if(sum == 1)
	{
		moveDrive(70, 40);
	}
	else if(sum == 0)
	{
		moveDrive(70, 70);
	}
	ClearTimer(T2);
	while(time1[T2] < 200 && (!SensorValue[TowerLimitL] || !SensorValue[TowerLimitR])) {}
	moveDrive(0, 0);
	wait1Msec(200);
	moveDrive(-80, -80);
	wait1Msec(420);
	moveDrive(0, 0);
	if(touching)
	{
	setRobot( 0, 'S', 1700, -127, 1, 0, 1400 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );
	}
	setRobot( 0, 'S', 0, 0, 0, 0, 15000 );

}


void theJoshLeft()
{
	resetEncoders();
	//setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );
	setRobot( 1225, 'S', 0, 127, 0, 1, 1500 );
	setRobot( -55, 'T', 0, 127, 0, 1, 500 );
	setRobot( 1525, 'S', 0, 127, 0, 0, 2800 );

	setRobot( 0, 'S', 0, 0, 0, 0, 15000 );

}

void theJosh()
{
	resetEncoders();
	//setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );
	setRobot( 1425, 'S', 1700, 0, 0, 1, 1500 );
	setRobot( -35, 'T', 1700, 0, 0, 1, 500 );
	setRobotPhysLimit( 1525, 'S', 1700, 0, 0, 0, 2800 );

	setRobot( 0, 'S', 1700, 0, 0, 0, 15000 );

}


void theJess()
{
	resetEncoders();
	//setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
	autonWait();
	int run_count = 0;
	int dist_last = SensorValue[EncoderR];
	moveDrive( -127, -127 );
	wait1Msec(90);
	SensorValue[PlatformPiston] = 1;
	wait1Msec(500);
	SensorValue[PlatformPiston] = 0;
	while( ++run_count <= 80 && dist_last - SensorValue[EncoderR] > 4)
	{
		dist_last = SensorValue[EncoderR];
		wait1Msec(25);
	}
	setRobot( 0, 'S', 0, 0, 0, 0, 15000);
}


void theDanielScoringFinalPart() //called by both theDaniel and theChinmay
{
	setRobot( -630, 'S', 50, 127, 0, 0, 1000 );
	setRobot( 550, 'R', 50, 127, 0, 0, 1000 );
	setRobot( 800, 'S', 60, 127, 0, 0, 1000 );
	setRobot( -200, 'T', 60, 127, 0, 0, 1000 );
	setRobot( -800, 'S', 60 , 127, 0, 0, 700 );
	setRobot( -200, 'S', 1700, 0, 0, 0, 2000 );
	setRobot( 670, 'S', 1700, 0, 0, 0, 850 );
	setRobot( 0, 'S', 1700, -127, 1, 0, 1000 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );


	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );

}

void theDaniel()
{
	resetEncoders();
	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );

	setRobot( 1325, 'S', 0, 127, 0, 0, 1500 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1000 );
	setRobot( -335, 'T', 0, 127, 0, 0, 1000 );
	setRobot( 1000, 'S', 0, 127, 0, 0, 1250 );
	setRobot( 0, 'S', 0, 127, 0, 0, 500 );

	setRobot( -475, 'S', 0, 40, 0, 0, 1250 );
	setRobot( 360, 'T', 0, 0, 0, 0, 1000 );
	setRobot( 925, 'S', 40, 127, 0, 0, 1000 );
	theDanielScoringFinalPart();
}

void theKarl()
{
	resetEncoders();
	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 1, 5000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
}

void theIshan()
{
	resetEncoders();
	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 1, 5000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
}

void theChinmay() // picks up pyramid and 5 under trough, score
{
	resetEncoders();

	//The following is unsuccessful version 1. We will attempt version 2 below using
	//code from the Daniel.

	/*setRobot( 0, 'S', 0, 0, 0, 0, 1000 );
	setRobot( 1260, 'S', 0, 127, 0, 0, 1500 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1000 );
	setRobot( -40, 'T', 0, 0, 0, 0, 750 );
	setRobot( 1200, 'S', 0, 127, 0, 0, 1250 );
	setRobot( -800, 'S', 0, 127, 0, 0, 750 );
	setRobot( 190, 'T', 0, 0, 0, 0, 1000 );
	setRobot( 1100, 'S', 0, 127, 0, 0, 750 );
	setRobot( -1650, 'S', 0, 127, 0, 0, 1000 );
	setRobot( -90 , 'T', 1700, 0, 0, 0, 2500 );
	setRobot( 900, 'S', 1700, 0, 0, 0, 750 );
	setRobot( 0, 'S', 1700, -127, 1, 0, 1200 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );

	setRobot( 0, 'S', 0, 0, 0, 0, 1000 ); */


	/*setRobot( 350, 'T', 0, 127, 0, 0, 2000);
	setRobot( -350, 'T', 0, 127, 0, 0, 2000);
	setRobot( -600, 'S', 0, 0, 0, 0, 1000);
	setRobot( 0, 'S', 1700, 0, 0, 0, 2500);
	setRobot( 600, 'S', 1700, 0, 0, 0, 2500);
	setRobot( 0, 'S', 1700, -127, 1, 0, 1200 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );*/

	//Version 2 (based on the Daniel)
	setRobot( 0, 'S', 0, 0, 0, 0, 1000 );

	setRobot( 1325, 'S', 0, 127, 0, 0, 1500 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1000 );
	setRobot( -80, 'T', 0, 0, 0, 0, 500 );
	setRobot( 720, 'S', 0, 0, 0, 0, 1000 );
	setRobot( 150, 'T', 0, 127, 0, 0, 1100 );
	setRobot( 400, 'S', 40, 127, 0, 0, 800 );
	setRobot ( 0, 'S', 0, 127, 0, 0, 200 ); //pause
	theDanielScoringFinalPart();
	//setRobot( 900, 'S', 0, 127, 0, 0, 1000 );
	//setRobot( 0, 'S', 0, 127, 0, 0, 300 );
	//setRobot( -500, 'S', 0, 0, 0, 0, 800 );

}

void theRickTyler()
{
	setRobot( 0, 'S', 0, 0, 0, 1, 700 );

	setRobot( 1545, 'S', 0, 127, 0, 1, 1700 );
	setRobot( 0, 'S', 0, 127, 0, 1, 1000 );
	setRobotPhysLimit( -2000, 'S', 0, 127, 0, 1, 2000 );
	autonWait();
	setRobot(3750, 'S', 0, 127, 0, 0, 3250);
	setRobot(0, 'S', 0, 127, 0, 0, 500 );
	setRobot(-400, 'S', 0, 0, 0, 0, 800 );
	setRobot(0, 'S', 1700, 0, 0, 0, 1500 );

	setRobotPhysLimit( 1275, 'S', 1700, 40, 0, 0, 1500 );
	bool touching = SensorValue[TowerLimitL] || SensorValue[TowerLimitR];
	//Daniel i have taken this out because it knocked over the ROBOT
	//adjust the power and figure out what is neccessary time wise --Chinmay
	int sum = SensorValue[TowerLimitL] * 2 + SensorValue[TowerLimitR];
	moveArm(35, 35);
	if(sum == 3)
	{
		moveDrive(40, 40);
	}
	else if(sum == 2)
	{
		moveDrive(40, 70);
	}
	else if(sum == 1)
	{
		moveDrive(70, 40);
	}
	else if(sum == 0)
	{
		moveDrive(70, 70);
	}
	ClearTimer(T2);
	while(time1[T2] < 200 && (!SensorValue[TowerLimitL] || !SensorValue[TowerLimitR])) {}
	moveDrive(0, 0);
	wait1Msec(200);
	moveDrive(-80, -80);
	wait1Msec(420);
	moveDrive(0, 0);
	if(touching)
	{
	setRobot( 0, 'S', 1700, -127, 1, 0, 1400 );
	setRobot( -700, 'S', 1700, -127, 0, 0, 1000 );
	}
	setRobot( 0, 'S', 0, 0, 0, 0, 15000 );

}

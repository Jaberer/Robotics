#pragma config(Sensor, in1,    Gyroscope,      sensorGyro)
#pragma config(Sensor, in2,    ArmPoten,       sensorPotentiometer)
#pragma config(Sensor, in3,    Left2Line,      sensorLineFollower)
#pragma config(Sensor, in4,    Left1Line,      sensorLineFollower)
#pragma config(Sensor, in5,    Right1Line,     sensorLineFollower)
#pragma config(Sensor, in6,    Right2Line,     sensorLineFollower)
#pragma config(Sensor, in7,    Left3Line,      sensorLineFollower)
#pragma config(Sensor, in8,    Right3Line,     sensorLineFollower)
#pragma config(Sensor, dgtl1,  ShaftLeft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ShaftRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Jumper3,        sensorTouch)
#pragma config(Sensor, dgtl6,  Jumper2,        sensorTouch)
#pragma config(Sensor, dgtl7,  Jumper1,        sensorTouch)
#pragma config(Sensor, dgtl8,  Jumper0,        sensorTouch)
#pragma config(Sensor, dgtl9,  Bump,           sensorTouch)
#pragma config(Motor,  port1,           LeftIntake,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           FrontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           BackLeft,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           LeftDownArm,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           LeftUpArm,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           RightUpArm,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           RightDownArm,  tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           BackRight,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           FrontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          RightIntake,   tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Drive: FrontLeft, BackLeft, FrontRight, BackRight
//Arm: LeftUpArm, RightUpArm, LeftDownArm, RightDownArm
//Intake: LeftIntake, RightIntake

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

void test(string input);

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//                                Method Declarations                               //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

void Forward(int power, int distance, string stopEvent);        //Drives forward at <power> for <distance> until <stopEvent> happens
void Backward(int power, int distance, string stopEvent);       //Drives backward at <power> for <distance> until <stopEvent> happens
void ForwardOnLine(int power, int distance, string stopEvent);  //Follows line forward at <power> for <distance> until <stopEvent> happens
void BackwardOnLine(int power, int distance, string stopEvent); //Follows line backward at <power> for <distance> until <stopEvent> happens
void VariableMove(int leftpower, int rightpower, int duration); //Drives left side at <leftpower, right side at <rightpower> for <duration> decimilliseconds

void TurnLeftDegrees(float degrees);  //Turns <degrees> amount of degrees left
void TurnRightDegrees(float degrees); //Turns <degrees> amount of degrees left

void GoForward(int power);            //Sets motors to go at <power> forward
void GoBackward(int power);           //Sets motors to go at <power> backward
void TurnLeft(int power);             //Sets motors to go at <power> left
void TurnRight(int power);            //Sets motors to go at <power> right

void StopMoving();                    //Stops the drive motors, sends opposite power for 0.01 seconds
void StopArm();                       //Stops the arm motors

//Line Sensors
float fAmountLeft();                  //Returns the amount left the robot is of the line
float fAmountRight();                 //Returns the amount right the robot is of the line

bool stopEventFunction(string stopEvent); //Returns a boolean value based off if stopEvent is attained or not
bool CheckAtIntersection();           //Returns true if reached an intersection, false otherwise

void LiftArm(int power);              //Sets arm to lift at <power>
void Intake(int power);               //Sets intake at <power>

//Gyroscope Movement
float AmountTurn();                       //Returns how much the robot is off it's desired orientation

void MoveArmToPreset(int newArmPosition); //Moves arm to <newArmPosition> preset

void IsolationBlockAutonomous();              //Blocks 20" fence goals
void IsolationScoringAutonomous();            //Picks up 3 objects, backs up to isolation starting tile, reposition to face 20" fence goals, scores 3 and 2 on 20" goals
void BlueIsolationPickupAutonomous();         //Picks up 3 objects, blocks 20" fence goals RED
void RedIsolationPickupAutonomous();          //Picks up 3 objects, blocks 20" fence goals BLUE

void InteractionGoalAutonomous();             //Raises arm and parks on goal
void InteractionInterceptionAutonomous();     //Backs up to interfere with other bot's autonomous
void InteractionAntiWallBot1Autonomous();     //Forward to get to the other side of the wall bot
void BlueInteractionAntiWallBot2Autonomous(); //Knocks the wall down onto our side BLUE
void RedInteractionAntiWallBot2Autonomous();  //Knocks the wall down onto our side RED
void BlueInteractionCurvyAutonomous();
void RedInteractionCurvyAutonomous();

void ProgrammingSkillsAutonomous();           //36pt Programming Skills run

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//                                 Variables                                        //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

float batteryLevel = nAvgBatteryLevel;

//Arm Potentiometre
int motorPower = 0;
float currentError;
const float kP = 0.40;
const int motorThres = 16; //under 16 --> motorPower = 0
const float kD = 3;//12;
float lastError = 0;
float derivative = 0;
const float kI = 0.002;
float integral = 0;

int armPosition = 1000;
const int minArm = 890;
const int stackHeight = 1010;
const int ballHeight = 0;//
const int lowGoalHeight = 1600;
const int midGoalHeight = 2000;
const int maxArm = 2520;
int armPresetTimer = 0;
bool armPositionTaskActive = false;

//Gyroscope Movement
const float turnSens = 3.0 / 10.0; //3 power per 1 degree of error
const float turnSens2 = 1.3;

//Line Following
float f1Sens = 20 / 1300.0;
float f2Sens = 25 / 1300.0;
float f3Sens = 35 / 1300.0;

float defaultLine = 2800;
float whiteLine = 1500;

float f1AmountLeft;
float f1AmountRight;
float f2AmountLeft;
float f2AmountRight;
float f3AmountLeft;
float f3AmountRight;

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//                                    Methods                                       //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

task KeepArmInPosition()
{
  while(true)
  {
    currentError = armPosition - SensorValue[ArmPoten];
    derivative = currentError - lastError;
    lastError = currentError;
    integral = 0.9 * integral + currentError;

    motorPower = kP * currentError + kD * derivative + kI * integral;
    motorPower = abs(motorPower) > motorThres ? motorPower : 0;

    if (armPosition >= maxArm && motorPower < 15)
      motorPower = 15;

    LiftArm(motorPower);
    endTimeSlice();
  }
}
task StayInPosition()
{
  SensorValue[ShaftLeft] = 0;
  SensorValue[ShaftRight] = 0;
  float sens = 2;

  while (true)
  {
    motor[FrontLeft] = SensorValue[ShaftLeft] * sens;
    motor[FrontRight] = SensorValue[ShaftRight] * sens;
    motor[BackLeft] = SensorValue[ShaftLeft] * sens;
    motor[BackRight] = SensorValue[ShaftRight] * sens;
  }
}
task autonomous()
{
  // armPosition = SensorValue[ArmPoten];
  // SensorValue(Gyroscope) = 0;
// InteractionAntiWallBot1Autonomous();
// BlueInteractionAntiWallBot2Autonomous();
// InteractionGoalAutonomous();

  int autonomous = 8 * SensorValue[Jumper3] + 4 * SensorValue[Jumper2] + 2 * SensorValue[Jumper1] + SensorValue[Jumper0];

  if      (autonomous == 0)   IsolationBlockAutonomous();
  else if (autonomous == 1)   IsolationScoringAutonomous();
  else if (autonomous == 2)   BlueIsolationPickupAutonomous();
  else if (autonomous == 3)   RedIsolationPickupAutonomous();
  else if (autonomous == 4)   InteractionGoalAutonomous();
  else if (autonomous == 5)   InteractionInterceptionAutonomous();
  else if (autonomous == 6)   InteractionAntiWallBot1Autonomous();
  else if (autonomous == 7)   BlueInteractionAntiWallBot2Autonomous();
  else if (autonomous == 8)   RedInteractionAntiWallBot2Autonomous();
  else if (autonomous == 9)   BlueInteractionCurvyAutonomous();
  else if (autonomous == 10)  RedInteractionCurvyAutonomous();
}
void test(string input)
{
  if (strcmp(input, "forward") == 0)
  {
    StopMoving();
  }
}
void Forward(int power, int distance, string stopEvent)
{
  if (abs(SensorValue[Gyroscope]) > 200)
    SensorValue[Gyroscope] = 0;
  SensorValue[ShaftLeft] = 0;
  ClearTimer(T3);
  int currentShaft = 0;
  int velocity = 0;
  while(abs(SensorValue[ShaftLeft]) < distance * 10)
  {
    motor[FrontLeft] = power - turnSens2 * AmountTurn();
    motor[FrontRight] = -power - turnSens2 * AmountTurn();
    motor[BackLeft] = power - turnSens2 * AmountTurn();
    motor[BackRight] = -power - turnSens2 * AmountTurn();

    if (time10(T4) > 10)
    {
	    velocity = abs(SensorValue[ShaftLeft] - currentShaft);
      currentShaft = SensorValue[ShaftLeft];
	    ClearTimer(T4);
    }
    if (velocity > 5) ClearTimer(T3);
    if (time10(T3) > 50) break;
    if (stopEventFunction(stopEvent)) break;
  }
}
void Backward(int power, int distance, string stopEvent)
{
  if (abs(SensorValue[Gyroscope]) > 200)
    SensorValue[Gyroscope] = 0;
  SensorValue[ShaftLeft] = 0;
  ClearTimer(T3);
  int currentShaft = 0;
  int velocity = 0;
  while(abs(SensorValue[ShaftLeft]) < distance * 10)
  {
    motor[FrontLeft] = -power - turnSens2 * AmountTurn();
    motor[FrontRight] = power - turnSens2 * AmountTurn();
    motor[BackLeft] = -power - turnSens2 * AmountTurn();
    motor[BackRight] = power - turnSens2 * AmountTurn();

    if (time10(T4) > 10)
    {
	    velocity = abs(SensorValue[ShaftLeft] - currentShaft);
      currentShaft = SensorValue[ShaftLeft];
	    ClearTimer(T4);
    }
    if (velocity > 5) ClearTimer(T3);
    if (time10(T3) > 50) break;
    if (stopEventFunction(stopEvent)) break;
  }
}
void ForwardOnLine(int power, int distance, string stopEvent) //Default: 45
{
  if (abs(SensorValue[Gyroscope]) > 200)
    SensorValue[Gyroscope] = 0;
  SensorValue[ShaftLeft] = 0;
  ClearTimer(T3);
  int currentShaft = 0;
  int velocity = 0;
  while(abs(SensorValue[ShaftLeft]) < distance * 10)
  {
    float amountLeft =  fAmountRight() - 0.1 * fAmountLeft() - AmountTurn();
    float amountRight = -fAmountLeft() + 0.1 * fAmountRight() - AmountTurn();

    amountLeft = amountLeft * power / 45;
    amountRight = amountRight * power / 45;

    motor[FrontLeft] = power + amountLeft;
    motor[FrontRight] = -power + amountRight;
    motor[BackLeft] = power + amountLeft;
    motor[BackRight] = -power + amountRight;

    if (time10(T4) > 10)
    {
	    velocity = abs(SensorValue[ShaftLeft] - currentShaft);
      currentShaft = SensorValue[ShaftLeft];
	    ClearTimer(T4);
    }
    if (velocity > 5) ClearTimer(T3);
    if (time10(T3) > 50) break;
    if (stopEventFunction(stopEvent)) break;
  }
}
void BackwardOnLine(int power, int distance, string stopEvent)
{
  if (abs(SensorValue[Gyroscope]) > 200)
    SensorValue[Gyroscope] = 0;
  SensorValue[ShaftLeft] = 0;
  ClearTimer(T3);
  int currentShaft = 0;
  int velocity = 0;
  while(abs(SensorValue[ShaftLeft]) < distance * 10)
  {
    float amountLeft = -fAmountRight() - 0.1 * fAmountLeft() - AmountTurn();
    float amountRight = fAmountLeft() - 0.1 * fAmountRight() - AmountTurn();

    amountLeft = amountLeft * power / 45;
    amountRight = amountRight * power / 45;

    motor[FrontLeft] = -power + amountLeft;
    motor[FrontRight] = power + amountRight;
    motor[BackLeft] = -power + amountLeft;
    motor[BackRight] = power + amountRight;

    if (time10(T4) > 10)
    {
	    velocity = abs(SensorValue[ShaftLeft] - currentShaft);
      currentShaft = SensorValue[ShaftLeft];
	    ClearTimer(T4);
    }
    if (velocity > 5) ClearTimer(T3);
    if (time10(T3) > 50) break;
    if (stopEventFunction(stopEvent)) break;
  }
}
void VariableMove(int leftpower, int rightpower, int duration)
{
  ClearTimer(T1);
  while(time10(T1) < duration)
  {
    motor[FrontLeft] = leftpower;
    motor[FrontRight] = -rightpower;
    motor[BackLeft] = leftpower;
    motor[BackRight] = -rightpower;

    if (stopEventFunction("none"))
      break;
  }
}
void TurnLeftDegrees(float degrees)
{
  SensorValue[Gyroscope] = 0;
  while(abs(SensorValue[Gyroscope]) < abs(degrees) * 10 * 0.935)
  {
    if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 300)
      TurnLeft(30);
    else if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 500)
      TurnLeft(40);
    else if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 700)
      TurnLeft(50);
    else
      TurnLeft(60);

    if (stopEventFunction("none"))
      break;
  }
  StopMoving();
}
void TurnRightDegrees(float degrees)
{
  SensorValue[Gyroscope] = 0;
  while(abs(SensorValue[Gyroscope]) < abs(degrees) * 10 * 0.935)
  {
    if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 300)
      TurnRight(30);
    else if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 500)
      TurnRight(40);
    else if (abs(degrees) * 10 - abs(SensorValue[Gyroscope]) < 700)
      TurnRight(50);
    else
      TurnRight(60);

    if (stopEventFunction("none"))
      break;
  }
  StopMoving();
}
void GoForward(int power)
{
  motor[FrontLeft] = power;
  motor[FrontRight] = -power;
  motor[BackLeft] = power;
  motor[BackRight] = -power;
}
void GoBackward(int power)
{
  GoForward(-power);
}
void TurnLeft(int power)
{
  motor[FrontLeft] = -power;
  motor[FrontRight] = -power;
  motor[BackLeft] = -power;
  motor[BackRight] = -power;
}
void TurnRight(int power)
{
  TurnLeft(-power);
}
void StopMoving()
{
  float lowerThres = 5;//35

  motor[FrontLeft] = -motor[FrontLeft] / abs(motor[FrontLeft]) * lowerThres;
  motor[FrontRight] = -motor[FrontRight] / abs(motor[FrontRight]) * lowerThres;
  motor[BackLeft] = -motor[BackLeft] / abs(motor[BackLeft]) * lowerThres;
  motor[BackRight] = -motor[BackRight] / abs(motor[BackRight]) * lowerThres;

  wait10Msec(10);

  motor[FrontLeft] = 0;
  motor[FrontRight] = 0;
  motor[BackLeft] = 0;
  motor[BackRight] = 0;
}
void StopArm()
{
  motor[LeftUpArm] = 0;
  motor[LeftDownArm] = 0;
  motor[RightUpArm] = 0;
  motor[RightDownArm] = 0;
}
//Line Sensors
float fAmountLeft()
{
	f1AmountLeft = defaultLine - SensorValue[Left1Line] > 0 ? f1Sens*(defaultLine - SensorValue[Left1Line]) : 0;
	f2AmountLeft = defaultLine - SensorValue[Left2Line] > 0 ? f2Sens*(defaultLine - SensorValue[Left2Line]) : 0;
	f3AmountLeft = defaultLine - SensorValue[Left3Line] > 0 ? f3Sens*(defaultLine - SensorValue[Left3Line]) : 0;
	  return (f1AmountLeft + f2AmountLeft + f3AmountLeft);
}
float fAmountRight()
{
	f1AmountRight = defaultLine - SensorValue[Right1Line] > 0 ? f1Sens*(defaultLine - SensorValue[Right1Line]) : 0;
	f2AmountRight = defaultLine - SensorValue[Right2Line] > 0 ? f2Sens*(defaultLine - SensorValue[Right2Line]) : 0;
	f3AmountRight = defaultLine - SensorValue[Right3Line] > 0 ? f3Sens*(defaultLine - SensorValue[Right3Line]) : 0;
	  return (f1AmountRight + f2AmountRight + f3AmountRight);
}
bool stopEventFunction(string stopEvent)
{
  if (vexRT[Btn7L] == 1)
    return true;
  else if (strcmp(stopEvent, "Intersection") == 0 && CheckAtIntersection())
    return true;
  else //none
    return false;
}
bool CheckAtIntersection()
{
  if (SensorValue[Left1Line]+SensorValue[Left2Line]+SensorValue[Left3Line]+SensorValue[Right1Line]+SensorValue[Right2Line]+SensorValue[Right3Line] < 7 * whiteLine)
    return true;
  else
    return false;
}
void LiftArm(int power) //positive = up
{
  motor[LeftUpArm] = -power;
  motor[LeftDownArm] = -power;
  motor[RightUpArm] = power;
  motor[RightDownArm] = power;
}
void Intake(int power) //positive = in
{
	motor[LeftIntake] = abs(power) > 10 ? power : 0;
	motor[RightIntake] = abs(power) > 10 ? -power : 0;
}
float AmountTurn() //Gyroscope Movement
{
  return turnSens * SensorValue(Gyroscope);
}
void MoveArmToPreset(int newArmPosition)
{
  // ClearTimer(T2);
  StartTask(KeepArmInPosition);
  armPosition = newArmPosition;
  // armPresetTimer = 100 / 1000 * abs(armPosition - SensorValue[ArmPoten]);
  armPositionTaskActive = true;
}

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//                                  User Control                                    //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
  // StartTask(KeepArmInPosition);
  armPosition = SensorValue[ArmPoten];
  while (true)
  {
//  #########################################-  Arm and Intake -########################################################

    // if (!armPositionTaskActive) LiftArm(127 * vexRT[Btn5U] - 127 * vexRT[Btn5D]);                      //Main joystick Control
    // Intake(127 * vexRT[Btn6U] - 127 * vexRT[Btn6D]);

    // if (!armPositionTaskActive) LiftArm(vexRT[Ch3Xmtr2]);                                              //Partner joystick Control
    // Intake(vexRT[Ch2Xmtr2]);

    if (!armPositionTaskActive) LiftArm(vexRT[Ch3Xmtr2] + 127 * vexRT[Btn5U] - 127 * vexRT[Btn5D]);       //Dual Control
    Intake(vexRT[Ch2Xmtr2] + 127 * vexRT[Btn6U] - 127 * vexRT[Btn6D]);

//  ############################################-  Drive -##############################################################

	  motor[FrontLeft] = abs(vexRT[Ch3]+vexRT[Ch1]) > 10 ? vexRT[Ch3]+vexRT[Ch1] : 0;
	  motor[BackLeft] = abs(vexRT[Ch3]+vexRT[Ch1]) > 10 ? vexRT[Ch3]+vexRT[Ch1] : 0;
	  motor[FrontRight] = abs(-vexRT[Ch3]+vexRT[Ch1]) > 10 ? -vexRT[Ch3]+vexRT[Ch1] : 0;
	  motor[BackRight] = abs(-vexRT[Ch3]+vexRT[Ch1]) > 10 ? -vexRT[Ch3]+vexRT[Ch1] : 0;

//  ##########################################- Arm Presets -###########################################################

    if (vexRT[Btn5DXmtr2] == 1)
      MoveArmToPreset(stackHeight);
    if (vexRT[Btn5UXmtr2] == 1)
      MoveArmToPreset(lowGoalHeight);
    if (vexRT[Btn6UXmtr2] == 1)
      MoveArmToPreset(midGoalHeight);
		if (vexRT[Btn6DXmtr2] == 1)
      MoveArmToPreset(maxArm);

    if (vexRT[Btn8U] == 1)
      armPosition = maxArm;
    if (vexRT[Btn8L] == 1)
      armPosition = midGoalHeight;
    if (vexRT[Btn8R] == 1)
      armPosition = lowGoalHeight;
    if (vexRT[Btn8D] == 1)
      armPosition = minArm;

    if (abs(vexRT[Ch3Xmtr2]) > 20) // || time10(T2) > armPresetTimer)
    {
      StopTask(KeepArmInPosition);
      armPositionTaskActive = false;
    }


    if (vexRT[Btn7U] == 1) ProgrammingSkillsAutonomous();
    if (vexRT[Btn7D] == 1)
    {
      Forward(127, 40, "none");
		  VariableMove(127, 20, 70);
		  Forward(127, 120, "none");
		  StopMoving();
		  StartTask(StayInPosition);
		  wait10Msec(1500);
		  StopTask(StayInPosition);
    }
    if (vexRT[Btn7R] == 1) {TurnLeftDegrees(90); wait10Msec(50); }
    if (vexRT[Btn8L] == 1) {TurnRightDegrees(90); wait10Msec(50); }

  }
}

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//                                 Autony Mouses                                    //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
void InteractionInterceptionAutonomous()
{
  SensorValue[Gyroscope] = 0;
  Intake(127);
  Backward(127, 90, "none");
  StopMoving();
  Intake(0);
  StartTask(StayInPosition);
	wait10Msec(1500);
	StopTask(StayInPosition);
	Backward(127, 25, "none");
	StopMoving();
	StartTask(StayInPosition);
	wait10Msec(500);
	StopTask(StayInPosition);
}

void InteractionAntiWallBot1Autonomous()
{
  SensorValue[Gyroscope] = 0;
  Forward(127, 140, "none");
  StopMoving();
  StartTask(StayInPosition);
	wait10Msec(2000);
	StopTask(StayInPosition);
}

void RedInteractionAntiWallBot2Autonomous()
{
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);
  Intake(127);
  Forward(127, 20, "none");
  Intake(0);
  StopMoving();

  armPosition = 1200;
  VariableMove(127, -10, 90);
  StopMoving();

  turnLeft(127);
  wait10Msec(20);
  Forward(127, 40, "none");
  StopMoving();
  StartTask(StayInPosition);
  wait10Msec(2000);
  StopTask(StayInPosition);
  StopTask(KeepArmInPosition);
}

void BlueInteractionAntiWallBot2Autonomous()
{
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);
  Intake(127);
  Forward(127, 20, "none");
  Intake(0);
  StopMoving();

  armPosition = 1200;
  VariableMove(-10, 127, 90);
  StopMoving();

  TurnRight(127);
  wait10Msec(20);

  Forward(127, 40, "none");
  StopMoving();

  StartTask(StayInPosition);
  wait10Msec(500);
  StopTask(StayInPosition);
  StopTask(KeepArmInPosition);
}

void InteractionGoalAutonomous()
{
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);
  Intake(127);
  armPosition = maxArm;
  wait10Msec(50);
  Intake(0);
  Forward(65, 70, "none");
  StopTask(KeepArmInPosition);
}

void IsolationBlockAutonomous()
{
  SensorValue[Gyroscope] = 0;
	StartTask(KeepArmInPosition);
	armPosition = midGoalHeight;
	wait10Msec(25);
	Intake(127);
	Forward(100, 80, "none");
	StopMoving();
	armPosition = midGoalHeight - 100;
	wait10Msec(80);
	StopTask(KeepArmInPosition);

  StopArm();

	StartTask(StayInPosition);
	wait10Msec(500);
	Intake(0);
	wait10Msec(1000);
	StopTask(StayInPosition);
}
void IsolationScoringAutonomous()
{
  SensorValue[Gyroscope] = 0;
	StartTask(KeepArmInPosition);

  armPosition = minArm;
  Intake(127);
  Forward(45, 135, "none");
  Backward(127, 35, "none");
  Intake(0);
  armPosition = midGoalHeight+50;
  Backward(127, 80, "none");
  StopMoving();

  while (SensorValue[Bump] == 0) {}

  Forward(65, 60, "none");
  StopMoving();
  wait10Msec(20);
  Intake(-127);
  wait10Msec(90);
  Intake(70);
  Backward(35, 30, "none");
  StopMoving();
  Intake(-127);
  wait10Msec(120);
  Intake(0);

  //VariableMove(-70, -20, 80);
  Backward(45, 20, "none");
  armPosition = minArm;
  Backward(45, 20, "none");
  StopMoving();
  wait10Msec(200);

  StopTask(KeepArmInPosition);

  StopArm();
}

void BlueIsolationPickupAutonomous()
{
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);

  armPosition = minArm;
  Intake(127);
  Forward(45, 125, "none");
  StopMoving();


  Backward(127, 90, "none");
  Intake(0);
  StopMoving();

  TurnRightDegrees(45);

  armPosition = midGoalHeight;
  wait10Msec(70);
  Intake(127);
  Forward(100, 60, "none");
  StopMoving();
  armPosition = midGoalHeight - 100;
  wait10Msec(50);
  StopTask(KeepArmInPosition);

  StopArm();

  StartTask(StayInPosition);
  wait10Msec(500);
  Intake(0);
  wait10Msec(1000);
  StopTask(StayInPosition);

}

void RedIsolationPickupAutonomous()
{
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);

  armPosition = minArm;
  Intake(127);
  Forward(45, 125, "none");
  StopMoving();


  Backward(127, 90, "none");
  Intake(0);
  StopMoving();

  TurnLeftDegrees(40);

  armPosition = midGoalHeight;
  wait10Msec(70);
  Intake(127);
  Forward(100, 60, "none");
  StopMoving();
  armPosition = midGoalHeight - 100;
  wait10Msec(50);
  StopTask(KeepArmInPosition);

  StopArm();

  StartTask(StayInPosition);
  wait10Msec(500);
  Intake(0);
  wait10Msec(1000);
  StopTask(StayInPosition);
}
void BlueInteractionCurvyAutonomous()
{
  Intake(127);
  Forward(127, 40, "none");
  Intake(0);
  VariableMove(127, 20, 80);
  SensorValue[Gyroscope] = 0;
  Forward(127, 80, "none");
  StopMoving();
  StartTask(StayInPosition);
  wait10Msec(1500);
  StopTask(StayInPosition);
}
void RedInteractionCurvyAutonomous()
{
  Intake(127);
  Forward(127, 40, "none");
  Intake(0);
  VariableMove(20, 127, 80);
  SensorValue[Gyroscope] = 0;
  Forward(127, 80, "none");
  StopMoving();
  StartTask(StayInPosition);
  wait10Msec(1500);
  StopTask(StayInPosition);
}
void ProgrammingSkillsAutonomous()
{
  armPosition = SensorValue[ArmPoten];
  SensorValue[Gyroscope] = 0;
  StartTask(KeepArmInPosition);

// A: Pick up stack at intersection
  armPosition = stackHeight;
  Intake(127);
  wait10Msec(40);
  Forward(45, 35, "none");

// B: Forward on line to doubler, pick up doubler, stop at intersection
  ForwardOnLine(45, 50, "none");
  Intake(0);
  ForwardOnLine(45, 100, "none");
  ForwardOnLine(45, 40, "none");  ///

  Intake(127);
  armPosition = minArm + 20;

  Forward(55, 100, "Intersection");
  StopMoving();
  armPosition = minArm + 100;
  Backward(45, 10, "Intersection"):
  Backward(45, 7, "none"):
  StopMoving();

// C: Turn 90° left to face 30" goal, forward, score doubler + 5 objects in 30" goal
  TurnLeftDegrees(91);
  Intake(0);
  armPosition = maxArm + 50;
  wait10Msec(100);
  Forward(50, 33.5, "none");
  StopMoving();
  Intake(-127);
  wait10Msec(60);
  Intake(-65);
  wait10Msec(60);
  Intake(-120);
  wait10Msec(40);
  Intake(-65);
  wait10Msec(60);
  Intake(-120);
  wait10Msec(80);
  // Intake(-127);
  // wait10Msec(250);
  Intake(0);

// D: Back up, lower arm, forward and pick up stack in front of 30" goal         //start of what grace programmed
  Backward(50, 50, "Intersection");
  wait10Msec(5);
  StopMoving();
  wait10Msec(20);
  armPosition = stackHeight + 20;
  wait10Msec(90);
  Intake(127);
  Forward(35, 28, "none"):
  StopMoving();

// E: Back up, turn 90° right to face 11.5" goal, score 11.5" goal
  Backward(35, 40, "Intersection");
  Backward(35, 8, "none");
  StopMoving();
  TurnRightDegrees(90);
  Intake(0);
  armPosition = lowGoalHeight;
  wait10Msec(20);
  Forward(35, 16, "none");
  StopMoving();
  wait10Msec(10);
  Intake(-85);
  wait10Msec(50);
  Intake(-0);
  wait10Msec(20);
  Intake(-85);
  wait10Msec(70);
  Intake(0);

// F: Back up to intersection, turn 90° right, forward a lot, pick up stack, score stack on 11.5" goal

  Backward(85, 30, "none");
  armPosition = stackHeight;
  // Backward(85, 50, "none");
  // Backward(65, 35, "none");
  // Backward(45, 40, "none");
  Backward(85, 120, "none");
  Backward(35, 70, "Intersection");
  wait10Msec(1);
  StopMoving();
  TurnRightDegrees(90);
  ForwardOnLine(35, 20, "none");
  ForwardOnLine(45, 80, "none");

  Intake(127);
  ForwardOnLine(45, 53, "none");

  // armPosition = stackHeight;////


  Forward(45, 40, "Intersection");
  StopMoving();
  armPosition = lowGoalHeight + 40;
  wait10Msec(40);
  Forward(45, 25, "none");
  StopMoving();
  Intake(-100);
  wait10Msec(55);
  Intake(-0);
  wait10Msec(20);
  Intake(-85);
  wait10Msec(55);
  Intake(0);

// G: Back up, pick up stack in front of 11.5" goal, back up to intersection, turn 90° left
  Backward(55, 28, "none");
  StopMoving();
  armPosition = stackHeight + 20;
  Intake(127);
  Forward(45, 40, "none");
  StopMoving();
  Backward(55, 60, "Intersection");
  Backward(45, 5, "none");
  StopMoving();
  TurnLeftDegrees(90);
  Backward(85, 40, "none");
  StopMoving();
  Intake(0);

//======================================== PART 2 ===============================================================

  while (SensorValue[Bump] == 0) {}

// A2: Go forward
  SensorValue[Gyroscope] = 0;
  Forward(50, 30, "none");

// B2: Forward on line to doubler, pick up doubler, stop at intersection
  ForwardOnLine(45, 130, "none");

   // ForwardOnLine(45, 20, "none");///

  Intake(127);
  armPosition = minArm + 40;
  Forward(55, 100, "Intersection");
  StopMoving();
  armPosition = minArm + 120;
  Backward(45, 10, "Intersection"):
  Backward(45, 5, "none"):
  StopMoving();

// C2: Turn 90° right to face 30" goal, forward, score doubler + 5 objects in 30" goal
  Intake(0);
  TurnRightDegrees(91);
  // Intake(0);
  StartTask(KeepArmInPosition);
  armPosition = maxArm + 50;
  wait10Msec(90);
  Forward(40, 40.5, "none");
  StopMoving();
  Intake(-100);
  wait10Msec(60);
  Intake(-55);
  wait10Msec(90);
  Intake(-100);
  wait10Msec(50);
  Intake(-55);
  wait10Msec(60);
  Intake(0);

// D2: Back up, lower arm, forward and pick up stack in front of 30" goal
  Backward(55, 50, "Intersection");
  StopMoving();
  wait10Msec(20);
  armPosition = stackHeight;
  wait10Msec(100);
  Intake(127);
  Forward(45, 22, "none"):
  StopMoving();

// E2: Back up, turn 180° left to face 20" goal, forward and pick up 2 objects
  Backward(55, 50, "Intersection");
  StopMoving();
  TurnLeftDegrees(186);
  Intake(0);
  armPosition = stackHeight + 180;
  wait10Msec(10);
  Intake(127);
  Forward(55, 14, "none");
  StopMoving();
  wait10Msec(5);
  armPosition = stackHeight + 300;
  Backward(55, 6, "none");
  armPosition = minArm + 60;
  wait10Msec(5);
  Forward(55, 30, "none");
  Backward(55, 20, "none");
  StopMoving();

//F2: Raise arm to midgoal height, score 2 and 2 on 20" goals
  armPosition = midGoalHeight + 40;
  wait10Msec(100);
  Intake(0);
  Forward(55, 13, "none");
  StopMoving();
  wait10Msec(10);
  Intake(-95);
  wait10Msec(300);

  /*
  wait10Msec(80);
  Intake(100);
  Forward(55, 27, "none");
  StopMoving();
  Intake(-95);
  wait10Msec(160);
  */

  StopTask(KeepArmInPosition);

}

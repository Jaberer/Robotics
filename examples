#pragma config(Motor,  port1,           leftWheel1, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           claw, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightWheel1, tmotorVex393, openLoop)
#pragma platform(VEX)
/** 
 *
 * THE ABOVE CODE IS AUTOMATICALLY GENERATED BY ROBOTC PROGRAM
 * Or... you can also write it yourself if you know what you're doing
 * There's example code you can always open within RobotC in the File Menu
 * RobotC download: http://www.robotc.net/download/vexrobotics/
 * RobotC documentation: http://help.robotc.net/WebHelpVEX/index.htm
 * 
 * NOTE: 
 *    This code sucks and is very "dumb" -- constant values and non-sensor based robots 
 *    are considered "unintelligent" as they can't detect the world around them, and 
 *    don't have the "intelligence", or programming necessary to possibly even try.
 * 
 */

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Motor Power Constants -- Min and Maximum is -127 to 127
int MAX_POWER = 127;
int MIN_POWER = -127;

//Pre-Auton Initialization -- Used in Competitions
void pre_auton() { /** Do nothing... */ }

//Autonomous mode -- Used in Competitions
task autonomous() { /** Do nothing... */ }

//User Control Mode
task usercontrol() {
	while (true) {
	
	  /** Drive Control */
	  assignDriveMotors(vexRT[Ch3], vexRT[Ch3]);
	  
	  /** Other Motor Control */
	  /** Maybe have some separate functionality for the claw? 
	  if(vexRT[Btn6U]) {
	    openClaw();
	  }
	  else {
	    closeClaw();
	  }
	  */
	  
	}
}

/** Helper Task to reset power values back to zero */
task reset() {
  assignDriveMotors(0, 0);
}

/** Task to assign power values to motors */
task assignDriveMotors(float leftWheel1Pow, float rightWheel1Pow) {
  	motor[leftWheel1] = leftWheel1Pow;
  	motor[rightWheel1] = rightWheel1Pow;
}

/** Task to open claw based on a time constant -- adjust as needed */
task openClaw() {
  motor[claw] = MAX_POWER;
  wait1Msec(500);
  motor[claw] = 0;
}

/** Task to close claw based on a time constant -- adjust as needed */
task closeClaw() {
  motor[claw] = MAX_POWER;
  wait1Msec(500);
  motor[claw] = 0;
}

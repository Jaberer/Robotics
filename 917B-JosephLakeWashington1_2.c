#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    AutonSelect,    sensorPotentiometer)
#pragma config(Sensor, in8,    RightArmAngle,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  blueWaitingButton, sensorTouch)
#pragma config(Sensor, dgtl12, redWaitingButton, sensorTouch)
#pragma config(Sensor, I2C_1,  LeftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           LeftArm,       tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RightFWheel,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           RightMWheel,   tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           RightBWheel,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           LeftIntake,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port6,           RightIntake,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port7,           LeftBWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           LeftMWheel,    tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           LeftFWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port10,          RightArm,      tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

/******************************************
///////// FINAL VARIABLES HERE ///////////
///////// PLACE NECESSARY USER ///////////
//////////CONTROL AND AUTON //////////////
///////// FUNCTIONS HERE /////////////////
******************************************/

////////////////////////////
//***** Drive Values *****//
////////////////////////////
int FORWARD = 0;
int BACKWARD = 1;
int LEFT = 2;
int RIGHT = 3;

int TILE = 684; // Theoretical calculation of 24"
int HALF_TILE = 342; // 12"
int TICK_THEORY = 2865; // ticks per hundred inches
int TICK_AVG = 2850; // ticks per hundred inches
int PRE_GOAL = 1550; // 1600 didn't work as well
int GOAL = 1850; // adjusted for ^
int RIGHT_ANGLE = 200; // 200 is consistent 75%

int magnitude = 64;
int control = 15;

////////////////////
//** Arm Values **//
////////////////////
int BARRIER = 1300;	// Potentiometer value for arm to go over 12" barrier
int LOW = 580;			// Potentiometer value for arm to reach minimum...Actual value is 550-590...Safety 600 is too high
int BUMP = 750;			// Lag between pinion and 60 tooth gear -> ranges 600-800...Safety 750
int HIGH = 1780;		// Ranges between 1750-1900, left is 1750 and right is 1880...Safety 1750
int PRE_HIGH = 1700;// Just before stretched maximum reach

int hold = 20; // Arbitrary Numbers tested: 45 too high, 30 holds, 25 holds, 20 holds

//////////////////////////
//**** AUTON SELECT ****//
//////////////////////////
int ALEX = 700;
int UDIT = 2000;
int DEVANSH = 3500;

/******************************************
///////// VOID FUNCTIONS HERE ////////////
///////// PLACE NECESSARY USER ///////////
//////////CONTROL AND AUTON //////////////
///////// FUNCTIONS HERE /////////////////
******************************************/
void pre_auton()
{
	bStopTasksBetweenModes = true; // This is necessary
}

////////////////////////////////////////////////////////////////////
//******************* Auton Calculations *************************//
////////////////////////////////////////////////////////////////////
int cubicScaling(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3; //dead zone of +-3...
}

int hardCubicScaling(int x)
{
	return ((x*x*x) / (127*127)); //dead zone of +- 25...
}

int goalTicks(int tenthsOfInches)
{
	/**************************
	time
	600 milliseconds is ~1-1.5 tiles
	ticks
	28 ticks undershoot / inch
	29 overshoot / inch
	28.5 average
	28.64791 theory / inch
	2865 / 100 inches
	342 ticks per half tile
	684 ticks per tile
	TICKS/DEGREE TO BE DETERMINED
	distance
	1 tile = 24"
	0.5 tile = 12"
	theory
	(360 deg / inches circumference) * inches goalDistance = EncoderTicks
	**************************/
	return (TICK_THEORY * tenthsOfInches) / 1000;
}

int newPwr(int driveTarget, int distance)
{
	return (1.11 * sqrt(driveTarget)) * sin(distance * PI / driveTarget);
}

int oldPwr(int driveTarget, int distance)
{
	return (64 * sin(distance * PI / driveTarget));
}

////////////////////////////////////////////////////
/********** Manual Control Functions Here *********/
////////////////////////////////////////////////////
/*
void manualDrive(int drive)
{
if(drive == SOFT_ARCADE_DRIVE) // Sai might like?
{
RightDrivePower = cubicScaling(Channel3) - cubicScaling(Channel1);
LeftDrivePower = cubicScaling(Channel3) + cubicScaling(Channel1);
}
else if(drive == ARCADE_DRIVE) // Joseph likes
{
RightDrivePower = Channel3 - Channel1;
LeftDrivePower = Channel3 + Channel1;
}
else if(drive == TANK_DRIVE) // Devansh?
{
RightDrivePower = Channel2;
LeftDrivePower = Channel3;
}
else if(drive == SOFT_TANK_DRIVE)
{
RightDrivePower = cubicScaling(Channel2);
LeftDrivePower = cubicScaling(Channel3);
}
else if(drive == HARD_TANK_DRIVE)
{
RightDrivePower = hardCubicScaling(Channel2);
LeftDrivePower = hardCubicScaling(Channel3);
}
else if(drive == HARD_ARCADE_DRIVE)
{
RightDrivePower = hardCubicScaling(Channel3) - hardCubicScaling(Channel1);
LeftDrivePower = hardCubicScaling(Channel3) + hardCubicScaling(Channel1);
}
}
*/

//void manualLift()
//{
//	/**************************
//	Liimits: Can't go lower than LOW
//	Arm Holding: Constant hold between PRE_HIGH and HIGH
//	**************************/

//	// Logic order -> if no input and already raised -> Constant
//	// 		If not -> Check Lowered Safety
//	//		If not -> Manual Control
//	//PRE-CONDITION: Arm Holding is Autonomous,
//	//No user input, but user needs to take manual on demand

//	if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0) //High Arm hold
//		&& (SensorValue[RightArmAngle] >= PRE_HIGH))
//	{ // If no input and at the same time either arm is above PRE_HIGH...
//		LiftPower = hold;
//	}
//	/*
//	else if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)// Everywhere Arm Hold - Removed due to no use and wasted battery
//		&& (SensorValue[RightArmAngle] >= BUMP|| SensorValue[LeftArmAngle] >= BUMP))
//	{
//		LiftPower = 25;// Arbitrary Numbers tested: 30 holds, 20 holds with noise, 25 holds fine
//	}*/
//	else if(SensorValue[RightArmAngle] <= LOW) //LOW Safety Limit
//		LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*0; // can only go up now
//	else // Full Manual
//		LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*127;
//}

////////////////////////////////////////////////////
//**********Auton Functions Here******************//
////////////////////////////////////////////////////
void setLeft(int pwr)
{
	motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = pwr;
}

void setRight(int pwr)
{
	motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = pwr;
}

void resetValues(int wait) //reset values to zero for safety - Encoders, Timers and Motors
{
	wait1Msec(wait);
	motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = 0;
	motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 0; // drive motors set to zero
	motor[LeftArm] = motor[RightArm] = 0; // arm motors set to zero
	motor[LeftIntake] = motor[RightIntake] = 0; // intake motors set to zero
	nMotorEncoder[LeftMWheel] = 0; //IEMs set to zero
}

void preciseDriveStop(int Case) // For now... Select each case to precision stop, idk how to get motor power
{
	if(Case == FORWARD) // FORWARD if moving forwards -> negative input sharp stop
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -10;
	else if(Case == BACKWARD) // BACKWARD etc...
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 10;
	else if(Case == LEFT) // LEFT
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = 10;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -10;
	}
	else if(Case == RIGHT) // RIGHT
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = -10;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 10;
	}
	else
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 0;
	wait10Msec(5); // stabilization time
	setRight(0); setLeft(0);
}

// time is in milliseconds
// distance is in tenths of inches
// direction is 1 or -1 -- positive is forwards
void moveStraight(int direction, int time, int driveTarget)
{
	nMotorEncoder[LeftMWheel] = 0;
	int distance = 0;
	float pwr = 0;
	while(distance < driveTarget )
	{
		distance = abs(nMotorEncoder[LeftMWheel]);
		// works
		if( distance <= driveTarget / 2)
			pwr = distance / 5 + 20; //TODO: figure out how this works
		else
			pwr = ( driveTarget - distance ) / 10 + 20;

		// test old formula
		//pwr = oldPwr(driveTarget, distance);
		// test new formula
		//pwr = newPwr(driveTarget, distance);

		pwr *= direction;
		setLeft(pwr);
		setRight(pwr);
	} // end while loop

	setLeft(0);
	setRight(0);
}

// direction is binary -1 or 1, positive is right
// time is milliseconds
// degrees is always positive
void spin(int direction, int time, int degrees) // 90 degrees is 200 both sides.
{
	nMotorEncoder[LeftMWheel] = 0;
	// Must test

	while(abs(nMotorEncoder[LeftMWheel]) < degrees)
	{
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -direction * magnitude;
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = direction * magnitude;
	}

	if(direction > 0)
		preciseDriveStop(RIGHT);
	else
		preciseDriveStop(LEFT);
}

void intake(bool direction)
{
	if(direction == true)
		motor[LeftIntake] = motor[RightIntake] = 80;
	else if (direction == false)
		motor[LeftIntake] = motor[RightIntake] = -127;
}

void lift(int targetPot)
{
	int currentPot = SensorValue[RightArmAngle]; // takes current Arm Angle
	while(currentPot != targetPot)
	{
		if(currentPot < targetPot)
		{
			motor[LeftArm] = motor[RightArm] = 127;	 //goes up if lower
		}
		/*
		else if(currentPot > targetPot)
		{
		motor[LeftArm] = motor[RightArm] = -127;	//goes down if higher
		}
		*/
		//wait1Msec(50);
		currentPot = SensorValue[RightArmAngle];
	}
}

void liftDown()
{
	while(SensorValue[RightArmAngle] > LOW)
	{
		motor[LeftArm] = motor[RightArm] = -127;
	}
	motor[LeftArm] = motor[RightArm] = 0;
}

void holdArm()
{
	motor[LeftArm] = motor[RightArm] = hold;
}

void stopIntake()
{
	motor[LeftIntake] = motor[RightIntake] = 0;
}

void waitForButton()
{
	while(SensorValue[redWaitingButton] == 0){}
}

void deploy()
{
	intake(true);
	wait1Msec(300);
	stopIntake();
}

void pickUpBall(int goals)
{
	resetValues(0);
	intake(true);
	wait10Msec(30);
	int current = 0;
	while(current < goals * 250)
	{
		setLeft(25); setRight(25);
		current = nMotorEncoder[LeftMWheel];
	}
	stopIntake();
	setLeft(0); setRight(0);
}

void crossBump()
{
	lift(BUMP);
	holdArm();
	nMotorEncoder[LeftMWheel] = 0;
	while(abs(nMotorEncoder[LeftMWheel]) < 300)
	{
		setRight(100); setLeft(100);
	}
	while(abs(nMotorEncoder[LeftMWheel]) < 600)
	{
		setRight(50); setLeft(50);
	}
	while(abs(nMotorEncoder[LeftMWheel]) < 800)
	{
		setRight(35); setLeft(35);
	}
	//liftDown();
	setRight(0); setLeft(0);
	//resetValues(0);
}

//////////////////////////////////////////////////////////////////////////////
//************************** Actual Competition Auton Here *****************//
//////////////////////////////////////////////////////////////////////////////

/* Psuedocode
Ramp Forward -> [Cross Barrier] -> Raise Arm HIGH -> Hold Arm HIGH -> Ramp Zero -> [Reach Goal] -> Outtake -> [Finish Outtake]
-> Stop Intake -> Ramp Forward -> Ramp Zero -> [Reach Barrier] -> Lower Arm LOW -> Ramp Backward -> [Reach Square] -> Hard Zero
Wait Until Press -> Raise Arm BARRIER -> Hold Arm BARRIER -> Ramp Forward -> Ramp Zero -> [Reach Barrier] -> Ramp Backward
-> [Reach Square] -> Hard Zero -> Wait Until Press -> Ramp Forward -> Ramp Zero -> [Reach Barrier]
*/
void Alex() // Caches preload (5) + Knocks 2 big balls (10)
{
	deploy();
	moveStraight(1, 0, 1550); // 1600 is just before goal...changed for some reason
	lift(HIGH); // only accurate to the nearest 100... may need to adjust HIGH value
	holdArm();
	moveStraight(1, 0, 300); // reaches goal
	//wait1Msec(1000);
	intake(false);
	wait1Msec(1000); // outtake
	stopIntake();
	moveStraight(-1, 0, 400); // move back away from goal...Apparently Safety is greater than move forward
	liftDown();
	moveStraight(-1, 0, 1500);
	waitForButton();
	lift(BARRIER);
	holdArm();
	intake(false);
	moveStraight(1, 0, 550); // estimated guess based on 10Q's values - WORKS
	wait1Msec(300);
	moveStraight(-1, 0, 550);
	waitForButton();
	moveStraight(1, 0, 950); // A bit of trouble... Not sure if you want to spin rollers for this hit...
	wait1Msec(300); // outtaking pushes the ball away + needs good aiming
	moveStraight(-1, 0, 950);
	resetValues(100);
}

/* Pseudo
Deploy -> Intake -> Ramp Forward -> Ramp Zero -> [Intake Two Balls] -> Hard Backward -> [Reach Square] -> Hard Zero
Wait Until Press -> *** Outtake [Finish Outtake] -> Stop All -> Wait Until Press -> *** -> Intake -> Ramp Forward
-> [Pick Up Ball] -> Ramp Zero -> Stop Intake -> [Reach Buckies] -> Spin -> [Knock Buckies] -> Outtake -> [Outtake Ball]
-> Spin -> Intake -> Ramp Forward	-> [Pick Up Ball] -> Spin -> Outtake Ball
*/
void blueDevansh() // Places preload (1-2) + 2 buckies (2-4) + TURN RIGHT Knocks buckies (1-6) + Places two Balls (2)
{
	deploy();
	intake(true);
	wait10Msec(10);
	moveStraight(1, 0, 475);
	wait10Msec(50);
	moveStraight(-1, 0, 475);
	//stopIntake();
	lift(BUMP);
	holdArm();
	waitForButton();
	intake(false);
	wait10Msec(100);
	waitForButton();
	resetValues(0);
	liftDown();
	// end Devansh
	waitForButton();
	intake(true);
	moveStraight(1, 0, (HALF_TILE));
	wait10Msec(50);
	pickUpBall(1);
	spin(1, 0, 200);
	lift(BUMP);
	holdArm();
	moveStraight(1, 0, (200));
	intake(false);
	// end udit
	resetValues(1000);
}

void redDevansh() // Places preload (1-2) + 2 buckies (2-4) + TURN LEFT Knocks buckies (1-6) + Places two Balls (2)
{
	deploy();
	intake(true);
	wait10Msec(10);
	moveStraight(1, 0, 475);
	wait10Msec(50);
	moveStraight(-1, 0, 475);
	//stopIntake();
	lift(BUMP);
	holdArm();
	waitForButton();
	intake(false);
	wait10Msec(100);
	waitForButton();
	resetValues(0);
	liftDown();
	// end Devansh
	waitForButton();
	intake(true);
	moveStraight(1, 0, (HALF_TILE));
	wait10Msec(50);
	pickUpBall(1);
	spin(-1, 0, 200);
	crossBump();
	lift(BARRIER);
	holdArm();
	wait10Msec(30);
	moveStraight(1, 0, 550);
	intake(false);
	// end udit
	resetValues(1000);
}

void blueUdit()
{
	deploy();
	intake(true);
	wait10Msec(10);
	moveStraight(1, 0, 475);
	wait10Msec(50);
	moveStraight(-1, 0, 475);
	//stopIntake();
	lift(BUMP);
	holdArm();
	waitForButton();
	intake(false);
	wait10Msec(100);
	resetValues(0);
	liftDown(); // added

	waitForButton();
	//liftDown();
	// end Devansh
	//waitForButton();
	intake(true);
	moveStraight(1, 0, (HALF_TILE));
	wait10Msec(50);
	pickUpBall(1);
	spin(1, 0, 200);
	//crossBump();
	lift(BUMP);
	nMotorEncoder[LeftMWheel] = 0;
	if(true)
	{
		setRight(127);
		wait10Msec(10);
		setLeft(127);
	}
	while (abs(nMotorEncoder[LeftMWheel]) < 500)
	{
		setRight(127); setLeft(127);
	}
	setRight(0); setLeft(0);
	lift(BARRIER);
	holdArm();
	wait10Msec(30);
	moveStraight(1, 0, 550);
	intake(false);
	// end udit
	resetValues(1000);
}

void redUdit()
{
	deploy();
	intake(true);
	wait10Msec(10);
	moveStraight(1, 0, 475);
	wait10Msec(50);
	moveStraight(-1, 0, 475);
	//stopIntake();
	lift(BUMP);
	holdArm();
	waitForButton();
	intake(false);
	wait10Msec(100);
	waitForButton();
	resetValues(0);
	liftDown();
	// end Devansh
	waitForButton();
	intake(true);
	moveStraight(1, 0, (HALF_TILE));
	wait10Msec(50);
	pickUpBall(1);
	spin(-1, 0, 200);
	crossBump();
	lift(BARRIER);
	holdArm();
	wait10Msec(30);
	moveStraight(1, 0, 550);
	intake(false);
	// end udit
	resetValues(1000);
}

void autonHangZoneAggro()
{

}

void autonHangZoneDef()
{

}

void autonMiddleZoneAggro()
{


}

void autonMiddleZoneDef()
{

}

void autonCustom()
{

}

void autonProgrammingSkills()
{

}

////////////////////////////////////////////// AUTON TESTING HERE //////////////////////////////////////////////////////////////

void autonTest1()
{
	Alex();
}

void autonTest2()
{
	redDevansh();
}

void autonTest3()
{
	blueDevansh();
}

void autonTest4()
{
	blueUdit();
}

void autonTest5()
{
	pickUpBall(1);
}

void autonTest6()
{
	spin(-1,0,100);
}

void autonTest7()
{

}

void autonTest8()
{

}

void testAuton()
{
	if(vexRT[Btn8L])
		autonTest1();
	else if(vexRT[Btn8R])
		autonTest2();
	else if(vexRT[Btn8U])
		autonTest3();
	else if(vexRT[Btn8D])
		autonTest4();
	else if(vexRT[Btn7L])
		autonTest5();
	else if(vexRT[Btn7R])
		autonTest6();
	else if(vexRT[Btn7U])
		autonTest7();
	else if(vexRT[Btn7D])
		autonTest8();
}

/*********************************************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Competition PROGRAM HERE ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
**********************************************************************************************************************************/
task autonomous()
{
	while(true)
	{
		if(SensorValue[redWaitingButton])
		{
			if(SensorValue[AutonSelect] < ALEX)
				Alex();
			else if(SensorValue[AutonSelect] < UDIT)
				redUdit();
			else if(SensorValue[AutonSelect] < DEVANSH)
				redDevansh();
			else{}
			break;
		} // end if
		else if(SensorValue[blueWaitingButton])
		{
			if(SensorValue[AutonSelect] < ALEX)
				Alex();
			else if(SensorValue[AutonSelect] < UDIT)
				blueUdit();
			else if(SensorValue[AutonSelect] < DEVANSH)
				blueDevansh();
			else{}
			break;
		} // end else if
	} // end while
} //end auton task

task usercontrol() // I wonder if I can change this to userControl()... stupid vex names LOL
{

	// Instance Variables
	int RightDrivePower, LeftDrivePower, LiftPower, IntakePower = 0;

	while(true)
	{

		/////////////////////////////
		//*** DEAD ZONE CONTROL ***//
		/////////////////////////////
	int Channel1 = abs(vexRT(Ch1)) < control ? 0 : vexRT(Ch1); // deadzone setting - if abs(x) greater than 15 -> 0, else real value
	int Channel2 = abs(vexRT(Ch2)) < control ? 0 : vexRT(Ch2); // deadzone setting - if abs(Channel2) greater than 15 -> 0, else real value
	int Channel3 = abs(vexRT(Ch3)) < control ? 0 : vexRT(Ch3); // deadzone setting - if abs(y) greater than 15 -> 0, else real value
	int Channel4 = abs(vexRT(Ch4)) < control ? 0 : vexRT(Ch4); // deadzone setting - if abs(Channel4) greater than 15 -> 0, else real value

		///////////////////////////////
		//****** DRIVE CONTROL ******//
		///////////////////////////////
		//manualDrive(ARCADE_DRIVE);

		RightDrivePower = Channel3 - Channel1;
		LeftDrivePower = Channel3 + Channel1;


		// hard cubic tank
/*
		RightDrivePower = cubicScaling(Channel2);
		LeftDrivePower = cubicScaling(Channel3);
*/
		///////////////////////////
		//***** LIFT CONTROL ****//
		///////////////////////////
		//manualLift();

		/**************************
		Liimits: Can't go lower than LOW
		Arm Holding: Constant hold between PRE_HIGH and HIGH
		**************************/

		// Logic order -> if no input and already raised -> Constant
		// 		If not -> Check Lowered Safety
		//		If not -> Manual Control
		//PRE-CONDITION: Arm Holding is Autonomous,
		//No user input, but user needs to take manual on demand

		if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0) //High Arm hold
			&& (SensorValue[RightArmAngle] >= BARRIER))
		{ // If no input and at the same time either arm is above PRE_HIGH...
			LiftPower = hold;
		}
		/*
		else if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)// Everywhere Arm Hold - Removed due to no use and wasted battery
		&& (SensorValue[RightArmAngle] >= BUMP))
		{
		LiftPower = hold;// Arbitrary Numbers tested: 30 holds, 20 holds with noise, 25 holds fine
		}*/
		else if(SensorValue[RightArmAngle] <= LOW) //LOW Safety Limit
			LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*0; // can only go up now
		else // Full Manual
			LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*127;

		//////////////////////////
		//*** Intake Control ***//
		//////////////////////////
		IntakePower = vexRT[Btn6U]*127 - vexRT[Btn6D]*127;

		/*************************
		****** TESTING AREA ******
		*************************/
		// comment this before competition
		//testAuton(); -- Alex help pls

		if(vexRT[Btn8L])
			autonTest1();
		else if(vexRT[Btn8R])
			autonTest2();
		else if(vexRT[Btn8U])
			autonTest3();
		else if(vexRT[Btn8D])
			autonTest4();
		else if(vexRT[Btn7L])
			autonTest5();
		else if(vexRT[Btn7R])
			autonTest6();
		else if(vexRT[Btn7U])
			autonTest7();
		else if(vexRT[Btn7D])
			autonTest8();

		//Set motors to each individual powers...
		motor[RightBWheel] = RightDrivePower; // port 4
		motor[RightMWheel] = RightDrivePower;		// port 3
		motor[RightFWheel] = RightDrivePower;		// port 2
		//setRight(RightDrivePower);
		motor[LeftFWheel] = LeftDrivePower;	// port 9
		motor[LeftMWheel] = LeftDrivePower;	//port 8
		motor[LeftBWheel] = LeftDrivePower;	//port 7
		//setLeft(LeftDrivePower);

		motor[RightArm] = motor[LeftArm] = LiftPower;

		motor[RightIntake] = motor[LeftIntake] = IntakePower;

	} // end while update loop
} // end task usercontrol

#pragma config(Sensor, in3,    Pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  piston,         sensorDigitalOut)
#pragma config(Motor,  port1,           rightBackMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           armBottomRight, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           armTopRight,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           armTopLeft,    tmotorVex393, openLoop)
#pragma config(Motor,  port8,           armBottomLeft, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           leftFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          leftBackMotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Control.c"
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Variables																			 //
/////////////////////////////////////////////////////////////////////////////////////////


// Potentiomter upsidedown - 4 March 2015 (Before State)
int ARM_DOWN = 4095; //WAS 1600
int ARM_UP = 2222;//WAS 100
int ARM_HOLD = 3750;//WAS 1400
int ARM_HOLD_POWER = 15; //WAS 20

float MAX_BOT = 3000, MIN_BOT = 1390; // keep three sigfigs
float MAX_TOP = 2700, MIN_TOP = 1420;
// Date is 4th of March, MAX_BOT is 3k, MAX_TOP is 2.7k, MIN_BOT is 1.39k, and MIN_TOP is 1.42k

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Functions																			 //
/////////////////////////////////////////////////////////////////////////////////////////
float cubeScaling(float inValue)
{
		return pow(inValue, 3) / pow(127, 3);
}

void pre_auton()
{

}

/**
 * Reset Motors Function.
 * Resets all the motors (Drive and Arm) to Zero
 */
void resetMotorValues()
{
	motor[leftBackMotor] = motor[leftFrontMotor] = motor[rightBackMotor] = motor[rightFrontMotor] = 0; // reset drive 
	motor[armBottomLeft] = motor[armBottomRight] = motor[armTopLeft] = motor[armTopRight] = 0; // reset arm
}

/**
 * Reset Sensors Function.
 * Resets all the sensors (encoders and gyro) to Zero
 */
void resetSensorValues()
{
	/*
	// drive encoders
	SensorValue[leftEncoder] = SensorValue[rightEncoder] = 0;
	// gyro
	SensorValue[gyro] = 0;
	*/
}

/**
 *	Proportional Forwards and Sideways driving code.
 *	float x is representative of the x vector component (1 or 0)
 *	float y is the y vector component (1 or 0)
 *	float target is the target encoder value to reach (ticks)
 *	float power is peak motor power (motor power)
 */
void forwardRamp(float x, float y, float target, float maxPower = 127) 
{
	float jAxis = (x - y); 
	float kAxis = (x + y);

	int currentCycle = SensorValue[leftEncoder] = 0; // resets at zero

	while(currentCycle < target)
	{
		motor[leftBackMotor] = jAxis * maxPower * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));
		motor[leftFrontMotor] = kAxis * maxPower * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));
		motor[rightBackMotor] = kAxis * maxPower * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));
		motor[rightFrontMotor] = jAxis * maxPower * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));

		currentCycle = SensorValue[leftEncoder]; // update current value
	}

	resetMotorValues(); // done
}

/**
 *	Proportional Spinning driving code.
 *	float direction is right or left (1 or -1)
 *	float target is the target encoder value to reach (ticks)
 *	float power is peak motor power (motor power)
 */
void spinRamp(float direction, float target, float maxPower = 127) 
{
	int currentCycle = SensorValue[leftEncoder] = 0; // resets at zero

	while (currentCycle < target)
	{
		motor[rightFrontMotor] = motor[leftFrontMotor] = 
			direction * power * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));

		motor[leftBackMotor] = motor[rightBackMotor] = 
			direction * power * -1 * (target - currentCycle) 
			/ sqrt(pow(target, 2) + pow(currentCycle, 2));	

		currentCycle = SensorValue[leftEncoder];
	}

	resetMotorValues(); // done
}

/**
 *	Lift Arm Up or Down function.
 *	float direction is 1 or -1 (up or down)
 *	float targetHeight is the target height
 *	float maxPower is the maximum power to peak at
 *  IMPORTANT NOTE: 4 March 2015 potentiometer is FLIPPED - so everything is flipped
 */
void liftArm(float direction, float targetHeight, float maxPower = 80)
{
	int currentCycle = SensorValue[Pot]; // cannot be modified

	if(direction > 0) // positive, go up
	{
		// with the pot flipped, target(up) will be smaller than current
		while(currentCycle > target) // still can go up... 
		{
			motor[armTopLeft] = motor[armBottomLeft] = motor[armTopRight] = motor[armBottomRight] = 
				direction * maxPower * (currentCycle - target) // current will continue to drop until target is reached - this is P
				/ sqrt(pow(target, 2) + pow(currentCycle, 2)); // normalize P vector

			currentCycle = SensorValue[Pot]; // update current value
		}
	}
	else // negative, go down
	{
		while(currentCycle < target) // still can go down - currentCycle goes up (arm goes down) till target reached
		{
			motor[armTopLeft] = motor[armBottomLeft] = motor[armTopRight] = motor[armBottomRight] = 
				direction * maxPower * (target - currentCycle) // this is P
				/ sqrt(pow(target, 2) + pow(currentCycle, 2)); // normalize P vector

			currentCycle = SensorValue[Pot]; // update current value
		}
	}

	resetMotorValues(); // done
}

/**
 * I don't know if this works as intended...
 */ 
void outtake(bool outtake)
{
	SensorValue[piston] = outtake;
}


/////////////////////////////////////////////////////////////////////////////////////////
//                                 Autonomous Task																	   //
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

}

////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task																	//
////////////////////////////////////////////////////////////////////////////////////////

task arm()
{
	float armPowerUp = 100; //Power values
	float armPowerDown = 50;
	int armPos;			 //Potentiometer values
	int armDir = 0;
	while(true)
	{
			armPos = SensorValue[Pot];
			armDir = vexRT[Btn6U] - vexRT[Btn6D];

			//motor[armTopLeft] = motor[armBottomLeft] = armDir*armPowerUp;
			//motor[armTopRight] = motor[armBottomRight] = armDir*armPowerUp;

			//Removed armPos <=ARM_DOWN
			if (armDir < 0) // negative, must go down
			{
					motor[armTopLeft] = motor[armBottomLeft] = -armPowerDown;
					motor[armTopRight] = motor[armBottomRight] = -armPowerDown;
			}

			else if (armDir > 0 && armPos >= ARM_UP) // positive and with room to go up, must go up
			{
					motor[armTopLeft] = motor[armBottomLeft] = armPowerUp;
					motor[armTopRight] = motor[armBottomRight] = armPowerUp;
			}

			//arm hold code
			else 
			{
					if(armPos <= ARM_HOLD) 
					{
							motor[armTopLeft] = motor[armBottomLeft] = ARM_HOLD_POWER;
							motor[armTopRight] = motor[armBottomRight] = ARM_HOLD_POWER;
					}
					else 
					{
							motor[armTopLeft] = motor[armBottomLeft] = 0;
							motor[armTopRight] = motor[armBottomRight] = 0;
					}
			}


	}
}

// TODO: IMPLEMENT THRESHOLD VALUES
task drive()
{
		//J-axis is front-left
		//K-axis is front-right
		float jAxis, kAxis, lAxis;
		float powerFL, powerFR, powerBL, powerBR;
		float basePowerFL, basePowerFR, basePowerBL, basePowerBR;
		float turnPercent;
		int turnDirection;
		float clutchZone = 10; // WAS 50...too large
		while (true)
		{
				jAxis = vexRT[Ch4] - vexRT[Ch3]; // WAS multiplied by 0.5
				kAxis = vexRT[Ch4] + vexRT[Ch3];
				lAxis = vexRT[Ch1];

				//cubic scaling on turn ratio for smoother turning
				turnPercent = abs(cubeScaling(lAxis));
				turnDirection = lAxis / abs(lAxis);

				if(abs(jAxis) - abs(kAxis) >= clutchZone)
				{  //Zone to 'pull' drifting stick motion to the axes
					float avg = (abs(jAxis) + abs(kAxis)) / 2; // average j,k values
					float jDir, kDir;  // either 1 or -1
					jDir = jAxis / abs(jAxis);
					kDir = kAxis / abs(kAxis);

				}

				basePowerFR = (1 - turnPercent) * jAxis;
				basePowerBL = (1 - turnPercent) * jAxis;
				basePowerFL = (1 - turnPercent) * kAxis;
				basePowerBR = (1 - turnPercent) * kAxis;


				powerFR = basePowerFR + turnPercent * turnDirection * 127;
				powerBL = basePowerBL + turnPercent * turnDirection * -127;
				powerFL = basePowerFL + turnPercent * turnDirection * 127;
				powerBR = basePowerBR + turnPercent * turnDirection * -127;

				//Don't forget to assign powers to the motors!
				motor[leftBackMotor] = powerBL;
				motor[leftFrontMotor] = powerFL;
				motor[rightBackMotor] = powerBR;
				motor[rightFrontMotor] = powerFR;


				if(vexRT[Btn7U] == 1)
				{
						writeDebugStream("%f", jAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", kAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", lAxis);
						writeDebugStreamLine(" ");
				}
		}
}

task autonTest()
{
		while(true)
		{
				if(vexRT[Btn7U] == 1)
				{
					forwardRamp(1, 0, 300); // drives to the right for 300 
					spinRamp(1, 300);

				}
				if(vexRT[Btn7D] == 1){
					forwardRamp(0, 1, 300); // drives to the front for 300 ticks
					spinRamp(-1, 300);
				}
				if(vexRT[Btn7R] == 1){
					forwardRamp(-1, 0, 300); // drives to the left for 300 ticks

				}
				if(vexRT[Btn7L] == 1){
	      			forwardRamp(0, -1, 300); // drives to the back for 300 ticks
	    	}
		}
}

task needle()
{
	while (true)
	{
		if (vexRT[Btn5U] == 1) // comment please
			SensorValue[piston] = 1;
		else if (vexRT[Btn5D] == 1)
			SensorValue[piston] = 0;
	}
}


task usercontrol()
{
		//StartTask(drive);
		StartTask(control);
		StartTask(arm);
		StartTask(needle);

		//StartTask(autonTest);
}

#pragma config(Sensor, in1,    LeftLiftAngle,  sensorPotentiometer)
#pragma config(Sensor, in8,    RightLiftAngle, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftArmBump,    sensorTouch)
#pragma config(Sensor, dgtl12, RightArmBump,   sensorTouch)
#pragma config(Motor,  port1,           LeftArm,       tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RightFWheel,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           RightMWheel,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           RightBWheel,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           LeftIntake,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port6,           RightIntake,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port7,           LeftBWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           LeftMWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port9,           LeftFWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port10,          RightArm,      tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	const int HISTORY = 20;
	// User control code here, inside the loop
	int RightDrivePower = 0, LeftDrivePower = 0, LiftPower = 0, IntakePower = 0;
	int RightDrivePowerHistory[HISTORY];
	int LeftDrivePowerHistory[HISTORY];
  unsigned int counter = 0;
  for (int j=0; j<HISTORY; j++)
  {
  	RightDrivePowerHistory[j] = 0;
  	LeftDrivePowerHistory[j] = 0;
  }

	while (true)
	{
		////////////////////////////////////////////
		//					DRIVE CONTROL
		////////////////////////////////////////////

		//Wheels
			// Left Joystick Forwards and backwards
			// Right Joystick controls turning

				// Linear Scaling
				RightDrivePower = vexRT(Ch3) - vexRT(Ch1);
				LeftDrivePower = vexRT(Ch3) + vexRT(Ch1);

				// Cubic Scaling - Dead zone of 3
					/*RightDrivePower = ((vexRT[Ch3]*vexRT[Ch3]*vexRT[Ch3]/3 + 2*vexRT[Ch3]/3) / (127*127)) - ((vexRT[Ch1]*vexRT[Ch1]*vexRT[Ch1]/3 + 2*vexRt[Ch1]/3)/(127*127));
					LeftDrivePower = ((vexRT[Ch3]*vexRT[Ch3]*vexRT[Ch3]/3 + 2*vexRT[Ch3]/3) / (127*127)) + ((vexRT[Ch1]*vexRT[Ch1]*vexRT[Ch1]/3 + 2*vexRt[Ch1]/3)/(127*127));
				*/
				/*
				if(abs(vexRT[Ch1]) > 15 || abs(vexRT[Ch3]) > 15)
				{
					RightDrivePower = vexRT[Ch3]^3 / (127^2) - vexRT[Ch1]/(127*1/2.0);	//go straight on Ch3, scale down on turning
					LeftDrivePower = vexRT[Ch3]^3 / (127^2) + vexRT[Ch1]/(127*1/2.0);
				}
				else
				{
						RightDrivePower = 0;
						LeftDrivePower = 0;
				}
				*/
				/*
				if(abs(vexRT[Ch1]) > 15) //&& abs(vexRT[Ch3]) < 15)
				{
					RightDrivePower = vexRT[Ch3]^3 / (127^2);
					LeftDrivePower = vexRT[Ch3]^3 / (127^2);
				}
				else if(abs(vexRT[Ch1]) > 15 && abs(vexRT[Ch3]) > 15)
				{
						RightDrivePower = vexRT[Ch3]^3 / (127^2) - (vexRT[Ch1]^3)/3 + (2*vexRT[Ch1]/3);
						LeftDrivePower = vexRT[Ch3]^3 / (127^2) + (vexRT[Ch1]^3)/3 + (2*vexRT[Ch1]/3);
				}*/
				/*
				else
				{
						RightDrivePower = 0;
						LeftDrivePower = 0;
				}*/
/*
		// record the power
		RightDrivePowerHistory[counter%HISTORY]=RightDrivePower;
		LeftDrivePowerHistory[counter%HISTORY]=LeftDrivePower;

		// caculate the average of last N powers
		int AverageRightDrivePower=0;
		int AverageLeftDrivePower=0;
		for (unsigned int i=0; i<HISTORY-1; i++)
		{
				unsigned int index = (counter+i)%HISTORY;
				AverageRightDrivePower += RightDrivePowerHistory[index]/(HISTORY-1);
				AverageLeftDrivePower += LeftDrivePowerHistory[index]/(HISTORY-1);
		}

		// scale down the power when tip risk is high
		float TipRiskPower = 127*2*(1.0/3.0);
		if (abs(RightDrivePower - AverageRightDrivePower) >= TipRiskPower)
		{
			RightDrivePower = (RightDrivePower + AverageRightDrivePower)/4;
		  RightDrivePowerHistory[counter%HISTORY]=RightDrivePower;
		}
		if (abs(LeftDrivePower - AverageLeftDrivePower) >= TipRiskPower)
		{
			LeftDrivePower = (LeftDrivePower + AverageLeftDrivePower)/4;
		  LeftDrivePowerHistory[counter%HISTORY]=LeftDrivePower;
		}

		counter++;
		if ( (counter%HISTORY) == 0) counter = 0;
*/
		//RightDrivePower = LeftDrivePower = vexRT(Ch3); ---- Testing purposes only ----

		//Lift
		// Bumper Switch Minimum Limit control
		if(SensorValue[LeftArmBump] == 1 || SensorValue[RightArmBump] == 1)
		{
				LiftPower = vexRT(Btn5U)*127 - vexRT(Btn5D)*0;
		}
		//"Jump" Arm Co9ntrol
		else if(SensorValue[RightLiftAngle] < 500 && vexRT[Btn8D] == 1)
		{
				LiftPower = vexRT[Btn8D]*5;
		}
		else //General Manual Control
		{
				LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*127;
		}
		IntakePower = vexRT[Btn6U]*127 - vexRT[Btn6D]*127;

		//motor[LeftCloseWheel] /*= motor[LeftMidWheel] = motor[LeftFarWheel] */ = LeftDrivePower;
		//motor[RightCloseWheel] = motor[RightMidWheel] = motor[RightFarWheel] = RightDrivePower;

		//TESTING EACH WHEEL
		motor[RightBWheel] = RightDrivePower; // port 4
		motor[RightMWheel] = RightDrivePower;		// port 3
		motor[RightFWheel] = RightDrivePower;		// port 2

		motor[LeftFWheel] = LeftDrivePower;	// port 9
		motor[LeftMWheel] = LeftDrivePower;	//port 8
		motor[LeftBWheel] = LeftDrivePower;	//port 7

		motor[RightArm] = motor[LeftArm] = LiftPower;
		motor[RightIntake] = motor[LeftIntake] = IntakePower;
	  // .....................................................................................

	  //UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}

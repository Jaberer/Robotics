#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LeftArmAngle,   sensorPotentiometer)
#pragma config(Sensor, in8,    RightArmAngle,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftArmBump,    sensorTouch)
#pragma config(Sensor, dgtl2,  autonClick,     sensorTouch)
#pragma config(Sensor, dgtl12, RightArmBump,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           LeftArm,       tmotorVex393, openLoop)
#pragma config(Motor,  port2,           RightFWheel,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           RightMWheel,   tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           RightBWheel,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           LeftIntake,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port6,           RightIntake,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port7,           LeftBWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           LeftMWheel,    tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port9,           LeftFWheel,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port10,          RightArm,      tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//ABOVE CONFIGURATION COPY AND PASTED FROM 917B-UYakima1-1.c -> Joseph's finished user control code

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

//Final Variables
///////////////////////////
//** Drive Directions ***//
///////////////////////////
int FORWARD = 0;
int BACKWARD = 1;
int LEFT = 2;
int RIGHT = 3;

////////////////////
//** Arm Values **//
////////////////////
int BARRIER = 1300;	// Potentiometer value for arm to go over 12" barrier
int LOW = 600;			// Potentiometer value for arm to reach minimum...Actual value is 550-590
int BUMP = 750;			// Lag between pinion and 60 tooth gear -> ranges 600-800...Safety 750
int HIGH = 1750;		// Ranges between 1750-1900, left is 1750 and right is 1880...Safety 1750
int PRE_HIGH = 1700;// Just before stretched maximum reach



/******************************************
///////// VOID FUNCTIONS HERE ////////////
///////// PLACE NECESSARY USER ///////////
//////////CONTROL AND AUTON //////////////
///////// FUNCTIONS HERE /////////////////
******************************************/

// Void functions below

void pre_auton()
{
	bStopTasksBetweenModes = true; // This is necessary
}

//turning is set to functions so that one cannot move while turning
//make sure to run the turn functions after the joystick input

//sets a function for a general rotating turn
void Rotate(int magnitude)
{
	motor[RightFWheel] = -magnitude;
	motor[RightMWheel] = -magnitude;
	motor[RightBWheel] = -magnitude;
	motor[LeftFWheel] = magnitude;
	motor[LeftMWheel] = magnitude;
	motor[LeftBWheel] = magnitude;
}

void MoveLinear(int magnitude)
{
	motor[RightFWheel] = magnitude;
	motor[RightMWheel] = magnitude;
	motor[RightBWheel] = magnitude;
	motor[LeftFWheel] = magnitude;
	motor[LeftMWheel] = magnitude;
	motor[LeftBWheel] = magnitude;
}
void Pivot(int fmagnitude, int smagnitude)
{
	motor[RightFWheel] = fmagnitude;
	motor[RightMWheel] = fmagnitude;
	motor[RightBWheel] = fmagnitude;
	motor[LeftFWheel] = fmagnitude;
	motor[LeftMWheel] = fmagnitude;
	motor[LeftBWheel] = fmagnitude;
	if(smagnitude < 0)
	{
		motor[LeftFWheel] += smagnitude;
		motor[LeftMWheel] += smagnitude;
		motor[LeftBWheel] += smagnitude;
	}
	else
	{
		motor[RightFWheel] -= fmagnitude;
		motor[RightMWheel] -= fmagnitude;
		motor[RightBWheel] -= fmagnitude;
	}
}

// Auton Functions here
// ALL DRIVE FUNCTIONS BASED ON TIME UNTIL ENCODERS INSTALLED

void resetValues() //reset values to zero for safety - Encoders, Timers and Motors
{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 0;
		// drive motors set to zero
		motor[LeftArm] = motor[RightArm] = 0;
		// arm motors set to zero
		motor[LeftIntake] = motor[RightIntake] = 0;
		// intake motors set to zero
		/******************************************************
		Pseudocode -
		SensorValue[LeftEncoder] = SensorValue[RightEncoder] = 0;
		*******************************************************/
}

void preciseDriveStop(int Case) // For now... Select each case to precision stop, idk how to get motor power
{
	if(Case == FORWARD) // FORWARD if moving forwards -> negative input sharp stop
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -1;
	else if(Case == BACKWARD) // BACKWARD etc...
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 1;
	else if(Case == LEFT) // LEFT
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = 1;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -1;
	}
	else if(Case == RIGHT) // RIGHT
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = -1;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 1;
	}
	else
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = 0;
}

//we need to calculate speed in units as "tiles/second"
// time is in milliseconds
void moveStraight(int magnitude, int time)
{
	motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = magnitude;
	wait1Msec(time); // wait1Msec only accepts milliseconds
	if(magnitude > 0)
		preciseDriveStop(FORWARD);
	else
		preciseDriveStop(BACKWARD);

	/* Pseudocode -
		while(SensorValue[RightEncoder]
	*/

}

void turn(int magnitude, int time, int direction) // direction is a either 1 or -1 -- negative is left turn, positive is right turn
{ // magnitude/2 is power of direction turn -- magnitude is power of opposite side
	// time is in seconds
	if(direction == -1)
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = direction*magnitude/2;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = direction*magnitude;
	}
	else if(direction == 1)
	{
		motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = direction*magnitude;
		motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = direction*magnitude/2;
	}

	wait1Msec(1000*time);
	/*
		Psuedocode -
		while(SensorValue[LeftEncoder] - SensorValule[RightEncoder] < 1000) according to Preetum 1k is the turning tick count
	*/
	// incorporating precise turning
	//TODO: change '1' and '2' to legit values
	if(direction == -1)
	{
			motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = -1;
			motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -2;
	}
	else if(direction == 1)
	{
			motor[LeftBWheel] = motor[LeftMWheel] = motor[LeftFWheel] = -2;
			motor[RightBWheel] = motor[RightMWheel] = motor[RightFWheel] = -1;
	}

	wait1Msec(10);
}


// AUTONOMOUS FUNCTIONS
// back is for by the hanging bar, front is for the first scoring area
void backBlue()//WORKS FOR BOTH BACK SLOTS
{
	//move straight into the balls in the corner
	MoveLinear(64); //half-speed forward motion
	wait1Msec(100); //wait to start the intake rolling
	motor[LeftIntake] = 127; //intake inwards to pick up balls
	motor[RightIntake] = 127;
	wait1Msec(500);
	preciseDriveStop(FORWARD);

	wait1Msec(1000);

	MoveLinear(-64);//reversing at half speed
	wait1Msec(600);
	preciseDriveStop(BACKWARD);

	wait1Msec(1000);

	Rotate(64);  //go for a ~165 degree turn
	wait1Msec(1000);
	Rotate(0); // end rotation

	wait1Msec(1000);

	motor[LeftArm] = 64;
	motor[RightArm] = 64;
	MoveLinear(64); //moves up to barrier
	wait1Msec(300);
	preciseDriveStop(FORWARD);

	wait1Msec(1000);
	motor[LeftArm] = 0;
	motor[RightArm] = 0;
	motor[LeftIntake] = -127; //output balls!
	motor[RightIntake] = -127;
	wait1Msec(900);

	wait1Msec(1000);

	Rotate(-64); //rotate to the left to pickup big ball
	wait1Msec(400);
	Rotate(0);

	wait1Msec(1000);

	MoveLinear(64);
	motor[LeftIntake] = 127; //intake inwards to pick up balls
	motor[RightIntake] = 127;
	wait1Msec(200);
	motor[LeftIntake] = 0;
	motor[RightIntake] = 0;
	wait1Msec(700);
	preciseDriveStop(FORWARD);


	wait1Msec(1000);

	Rotate(64); //point towards scoring zones
	wait1Msec(200);
	Rotate(0);

	wait1Msec(1000);

	motor[LeftIntake] = -127; //output balls!
	motor[RightIntake] = -127;
	wait1Msec(500);

}

void backRed()
{
	//move straight into the balls in the corner
	MoveLinear(64); //half-speed forward motion
	wait1Msec(100); //wait to start the intake rolling
	motor[LeftIntake] = 127; //intake inwards to pick up balls
	motor[RightIntake] = 127;
	wait1Msec(500);
	preciseDriveStop(FORWARD);

	wait1Msec(1000);

	MoveLinear(-64);//reversing at half speed
	wait1Msec(600);
	preciseDriveStop(BACKWARD);

	wait1Msec(1000);

	Rotate(-64);  //go for a ~165 degree turn
	wait1Msec(1000);
	Rotate(0); // end rotation

	wait1Msec(1000);

	motor[LeftArm] = 64;
	motor[RightArm] = 64;
	MoveLinear(64); //moves up to barrier
	wait1Msec(300);
	preciseDriveStop(FORWARD);

	wait1Msec(1000);
	motor[LeftArm] = 0;
	motor[RightArm] = 0;
	motor[LeftIntake] = -127; //output balls!
	motor[RightIntake] = -127;
	wait1Msec(900);

	wait1Msec(1000);

	Rotate(64); //rotate to the left to pickup big ball
	wait1Msec(400);
	Rotate(0);

	wait1Msec(1000);

	MoveLinear(64);
	motor[LeftIntake] = 127; //intake inwards to pick up balls
	motor[RightIntake] = 127;
	wait1Msec(200);
	motor[LeftIntake] = 0;
	motor[RightIntake] = 0;
	wait1Msec(700);
	preciseDriveStop(FORWARD);


	wait1Msec(1000);

	Rotate(-64); //point towards scoring zones
	wait1Msec(200);
	Rotate(0);

	wait1Msec(1000);

	motor[LeftIntake] = -127; //output balls!
	motor[RightIntake] = -127;
	wait1Msec(500);
}

void frontBlue() //12 - point auton
// lose preset into goal zone
// raise arm -> drive forward to knock ball over
// drive back - spin 30 degreeso - drive forward to knock other ball over
{
	////after flip intake completes
	////motor[LeftIntake] = motor[RightIntake] = -127; // spin ball out
	////wait1Msec(1000);
	//motor[LeftArm] = motor[RightArm] = 127;
	//wait1Msec(200); // raise to mid height
	//motor[LeftArm] = motor[RightArm] = 0; //elastics 'should' keep it holding. will require testing;
	//wait1Msec(1000);
	//MoveLinear(64); // robot should be pointing towards First ball
	//wait1Msec(200);
	//MoveLinear(0); // non-precision stop
	//wait1Msec(1000); // give time to allow all inertia to die out
	//MoveLinear(-64); // move backwards
	//motor[LeftArm] = motor[RightArm] = -127; //arm back down to minimize tipping
	//wait1Msec(200);
	//MoveLinear(0); //stoppu
	//while(true)
	//{
	//	if(SensorValue[autonClick] == 1)
	//	{
	//		break;
	//	}
	//}
	//motor[LeftArm] = motor[RightArm] = 127;
	//wait1Msec(200); // raise to mid height
	//motor[LeftArm] = motor[RightArm] = 0; //elastics 'should' keep it holding. will require testing;
	//wait1Msec(1000);
	//MoveLinear(64); // robot should be pointing towards First ball
	//wait1Msec(440);
	//MoveLinear(0);
	//wait1Msec(1000); // give time to allow all inertia to die out
	//MoveLinear(-64); // move backwards
	//motor[LeftArm] = motor[RightArm] = -127; //arm back down to minimize tipping
	//wait1Msec(200);
	//MoveLinear(0); //stoppu



	MoveLinear(64);
	wait1Msec(130);
	Rotate(-64);  //go for a ~165 degree turn
  wait1Msec(550);
	Rotate(0); // end rotation
	MoveLinear(127);
	wait1Msec(350);



}

void frontRed()
{
	motor[LeftArm] = motor[RightArm] = 127;
	wait1Msec(200); // raise to mid height
	motor[LeftArm] = motor[RightArm] = 0; //elastics 'should' keep it holding. will require testing;
	wait1Msec(1000);
	MoveLinear(64); // robot should be pointing towards First ball
	wait1Msec(200);
	MoveLinear(0); // non-precision stop
	wait1Msec(1000); // give time to allow all inertia to die out
	MoveLinear(-64); // move backwards
	motor[LeftArm] = motor[RightArm] = -127; //arm back down to minimize tipping
	wait1Msec(200);
	MoveLinear(0); //stoppu
	while(true)
	{
		if(SensorValue[autonClick] == 1)
		{
			break;
		}
	}
	motor[LeftArm] = motor[RightArm] = 127;
	wait1Msec(200); // raise to mid height
	motor[LeftArm] = motor[RightArm] = 0; //elastics 'should' keep it holding. will require testing;
	wait1Msec(1000);
	MoveLinear(64); // robot should be pointing towards First ball
	wait1Msec(440);
	MoveLinear(0);
	wait1Msec(1000); // give time to allow all inertia to die out
	MoveLinear(-64); // move backwards
	motor[LeftArm] = motor[RightArm] = -127; //arm back down to minimize tipping
	wait1Msec(200);
	MoveLinear(0); //stoppu


}


void autonomousTest()
{
	int clicks = 0;
	bool lastState = false;
	bool currentState = false;
	//flip the intake out
	motor[LeftArm] = motor[RightArm] = 127;
	wait1Msec(200);
	 motor[LeftIntake] = 127;
	 motor[RightIntake] = 127;
	 wait1Msec(1200);//subject to change
	//bring arm back down
	//while(SensorValue[LeftArmBump] != 1 || SensorValue[RightArmBump] != 1)
	//{
	//	if(SensorValue[LeftArmBump] != 1)
	//		motor[LeftArm] = -80;
	//	if(SensorValue[RightArmBump] != 1)
	//		motor[RightArm] = -80;
	//}

	 motor[LeftIntake] = 0;
	 motor[RightIntake] = 0;

	 motor[LeftArm] = motor[RightArm] = -100;
	 wait1Msec(600);

	 motor[LeftArm] = motor[RightArm] = 0;

	 //for(int i = 0; i < 2000; i++)
	 //{


	 //  lastState = currentState;
	 //  if(SensorValue[autonClick] == 1)
	 //  {
	 //    currentState = true;
	 //  }
	 //  if (currentState == false && lastState == true)
	 //  {
	 //    clicks++;
	 //  }
	 //  wait1Msec(1);
	 //}
	 switch(clicks%4)
	 {
	   case 0:
	   backBlue();
	   break;

	   case 1:
	   backRed();
	   break;

	   case 2:
	   frontBlue();
	   break;

	   case 3:
	   frontRed();
	   break;
	 }



}




/*****************************************************
//////// AUTONOMOUS PROGRAM HERE /////////////////////
*****************************************************/
task autonomous()
{
	/*
	int clicks = 0;
	bool lastState = false;
	bool currentState = false;
	//flip the intake out
	motor[LeftArm] = motor[RightArm] = 127;
	 motor[LeftIntake] = 127;
	 motor[RightIntake] = 127;
	 wait1Msec(1400);//subject to change
	//bring arm back down
	//while(SensorValue[LeftArmBump] != 1 || SensorValue[RightArmBump] != 1)
	//{
	//	if(SensorValue[LeftArmBump] != 1)
	//		motor[LeftArm] = -80;
	//	if(SensorValue[RightArmBump] != 1)
	//		motor[RightArm] = -80;
	//}

	 motor[LeftIntake] = 0;
	 motor[RightIntake] = 0;

	 motor[LeftArm] = motor[RightArm] = -100;
	 wait1Msec(600);

	 motor[LeftArm] = motor[RightArm] = 0;

	 for(int i = 0; i < 2000; i++)
	 {


	   lastState = currentState;
	   if(SensorValue[autonClick] == 1)
	   {
	     currentState = true;
	   }
	   if (currentState == false && lastState == true)
	   {
	     clicks++;
	   }
	   wait1Msec(1);
	 }
	 switch(clicks%4)
	 {
	   case 1:
	   backBlue();
	   break;

	   case 0:
	   backRed();
	   break;

	   case 2:
	   frontBlue();
	   break;

	   case 3:
	   frontRed();
	   break;
	 }


*/
}

task usercontrol()
{
	//Joseph didnt liek code

	//int initialPLeft;
	//int initialPRight;

	//initialPLeft = SensorValue[LeftLiftAngle];
	//initialPRight = SensorValue[RightLiftAngle];	//sets intial values to starting c value of potentiometer

	//int leftStickY;
	//int rightStickX;


	const int HISTORY = 20;
	// User control code here, inside the loop
	int RightDrivePower = 0, LeftDrivePower = 0, LiftPower = 0, IntakePower = 0;
	int RightDrivePowerHistory[HISTORY];
	int LeftDrivePowerHistory[HISTORY];
  unsigned int counter = 0;
  for (int j=0; j<HISTORY; j++)
  {
  	RightDrivePowerHistory[j] = 0;
  	LeftDrivePowerHistory[j] = 0;
  }
	while(true)
	{
///////////////////////////////
//****** DRIVE **************//
///////////////////////////////

// Halo Drive
	//Linear Scaling
	    RightDrivePower = vexRT(Ch3) - vexRT(Ch1);
			LeftDrivePower = vexRT(Ch3) + vexRT(Ch1);

// Manual Tank
			/* //Soft Cubic Scaling - Doesn't Work
			RightDrivePower = ((vexRT[Ch2]*vexRT[Ch2]*vexRT[Ch2]/3 + 2*vexRT[Ch2]/3) / (127*127));
			LeftDrivePower = ((vexRT[Ch3]*vexRT[Ch3]*vexRT[Ch3]/3 + 2*vexRT[Ch3]/3) / (127*127));
			*/

			/* // Hard Cubic Scaling - Doesn't Work
			RightDrivePower = ((vexRT[Ch2]*vexRT[Ch2]*vexRT[Ch2]) / (127*127));
			LeftDrivePower = ((vexRT[Ch3]*vexRT[Ch3]*vexRT[Ch3]) // (127*127));
			*/

///////////////////////////
//***** LIFT CONTROL ****//
///////////////////////////

/**************************
Liimits: Can't go lower than LOW
Arm Holding: Constant magnitude between PRE_HIGH and HIGH
**************************/

// Logic order -> if no input and already raised -> Constant
// 		If not -> Check Lowered Safety
//		If not -> Manual Control
//PRE-CONDITION: Arm Holding is Autonomous,
//No user input, but user needs to take manual on demand

if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0) //High Arm hold
	&& (SensorValue[RightArmAngle] >= PRE_HIGH || SensorValue[LeftArmAngle] >= PRE_HIGH))
{ // If no input and at the same time either arm is above PRE_HIGH...
	LiftPower = 25;// Arbitrary Numbers tested: 45 too high, 30 holds
}
/*
else if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)// Everywhere Arm Hold - Removed due to no use
	&& (SensorValue[RightArmAngle] >= BUMP|| SensorValue[LeftArmAngle] >= BUMP))
{
	LiftPower = 25;// Arbitrary Numbers tested: 30 holds, 20 holds with noise, 25 holds fine
}*/
else if(SensorValue[LeftArmAngle] <= LOW || SensorValue[RightArmAngle] <= LOW) //LOW Safety Limit
	LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*0; // can only go up now
else // Full Manual
	LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*127;

//////////////////////////
//*** Intake Control ***//
//////////////////////////
	IntakePower = vexRT[Btn6U]*127 - vexRT[Btn6D]*127;

/*************************
****** TESTING AREA ******
*************************/
/*
		if(vexRT[Btn8L] == 1)
		{
			autonomousTest();
		}
		*/
		//if(vexRT[Btn8R] == 1)
		//{
		//	backRed();
		//}

		//TESTING EACH WHEEL
		motor[RightBWheel] = RightDrivePower; // port 4
		motor[RightMWheel] = RightDrivePower;		// port 3
		motor[RightFWheel] = RightDrivePower;		// port 2

		motor[LeftFWheel] = LeftDrivePower;	// port 9
		motor[LeftMWheel] = LeftDrivePower;	//port 8
		motor[LeftBWheel] = LeftDrivePower;	//port 7

		motor[RightArm] = motor[LeftArm] = LiftPower;
		motor[RightIntake] = motor[LeftIntake] = IntakePower;



	}
}
